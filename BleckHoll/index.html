<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>–ß—ë—Ä–Ω–∞—è –î—ã—Ä–∞: –ë–µ—Å–∫—Ä–∞–π–Ω–∏–π –ö–æ—Å–º–æ—Å</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; touch-action: none; font-family: 'Segoe UI', Tahoma, sans-serif; overflow: hidden; color: white; }
    canvas { display: block; }

    #menu {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #0a041a, #140a2a);
      z-index: 100;
      opacity: 1;
      pointer-events: auto;
      transition: opacity 0.6s;
    }
    #menu.hidden { opacity: 0; pointer-events: none; }
    #title {
      font-size: 48px;
      font-weight: 900;
      margin-bottom: 36px;
      background: linear-gradient(90deg, #e0b3ff, #b16ce9, #8a2be2);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      background-size: 300% auto;
      animation: titleShine 6s infinite linear;
      text-shadow: 0 0 25px rgba(138, 43, 226, 0.6);
    }
    @keyframes titleShine {
      to { background-position: 300% center; }
    }
    .btn {
      padding: 14px 44px;
      font-size: 22px;
      border: none;
      border-radius: 60px;
      background: linear-gradient(90deg, #9a4cff, #5e17eb);
      color: white;
      cursor: pointer;
      margin: 12px;
      width: 260px;
      font-weight: bold;
      letter-spacing: 1px;
      box-shadow: 0 6px 22px rgba(154, 76, 255, 0.7);
      transition: all 0.25s;
    }
    .btn:hover {
      transform: translateY(-4px) scale(1.03);
      box-shadow: 0 8px 30px rgba(154, 76, 255, 0.9);
    }

    #ui {
      position: absolute;
      top: 22px;
      left: 22px;
      font-size: 19px;
      text-shadow: 0 0 8px rgba(138, 43, 226, 0.9);
      z-index: 10;
      opacity: 0;
      transition: opacity 0.6s;
    }
    #ui.visible { opacity: 1; }
    #ui div { margin: 5px 0; font-weight: 500; }

    #coordinates {
      position: absolute;
      top: 22px;
      right: 22px;
      font-size: 19px;
      text-shadow: 0 0 8px rgba(138, 43, 226, 0.9);
      z-index: 10;
      opacity: 0;
      transition: opacity 0.6s;
      font-weight: 500;
      letter-spacing: 1px;
    }
    #coordinates.visible { opacity: 1; }

    #joystick,
    #lookJoystick {
      position: absolute;
      width: 84px;
      height: 84px;
      border-radius: 50%;
      display: none;
      pointer-events: none;
      z-index: 20;
    }
    #joystick {
      border: 2px solid rgba(138, 43, 226, 0.6);
      background: rgba(94, 23, 235, 0.08);
    }
    #lookJoystick {
      border: 2px solid rgba(66, 200, 255, 0.5);
      background: rgba(30, 144, 255, 0.08);
    }

    #joystick-inner,
    #lookJoystick-inner {
      position: absolute;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    #joystick-inner {
      background: #9a4cff;
      box-shadow: 0 0 12px #9a4cff;
    }
    #lookJoystick-inner {
      background: #44aaff;
      box-shadow: 0 0 12px #44aaff;
    }

    #gameOver {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(10, 4, 26, 0.92);
      z-index: 50;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.6s;
    }
    #gameOver.visible {
      opacity: 1;
      pointer-events: auto;
    }
    #gameOver h2 {
      font-size: 38px;
      margin-bottom: 22px;
      color: #ff66cc;
      text-shadow: 0 0 16px rgba(255, 102, 204, 0.7);
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.03); }
    }
    #finalScore {
      font-size: 26px;
      margin-bottom: 32px;
      color: #b16ce9;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="menu">
    <div id="title">–ß–Å–†–ù–ê–Ø –î–´–†–ê</div>
    <button id="startBtn" class="btn">–ò–≥—Ä–∞—Ç—å</button>
  </div>

  <div id="ui">
    <div>–û—á–∫–∏: <span id="score">0</span></div>
    <div>–†–∞–∑–º–µ—Ä: <span id="size">3.0</span></div>
    <div>–í—Å–µ–ª–µ–Ω–Ω–∞—è: <span id="universe">72000¬≥</span></div>
  </div>
  
  <div id="coordinates">X: 0  Y: 0  Z: 0</div>

  <div id="joystick"><div id="joystick-inner"></div></div>
  <div id="lookJoystick"><div id="lookJoystick-inner"></div></div>

  <div id="gameOver">
    <h2>–í–∞—Å –ø–æ–≥–ª–æ—Ç–∏–ª–∞ –¥—Ä—É–≥–∞—è –¥—ã—Ä–∞...</h2>
    <div>–û—á–∫–∏: <span id="finalScore">0</span></div>
    <button id="restartBtn" class="btn">–ó–∞–Ω–æ–≤–æ</button>
    <button id="menuBtn" class="btn" style="background:linear-gradient(90deg, #ff66cc, #ff0077);">–í –º–µ–Ω—é</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
  <script>
    // === CONFIG ===
    const START_RADIUS = 3.0;
    const MAX_OBJECTS = 3000;
    const SPAWN_INTERVAL = 80;
    const MAX_PLAYER_SPEED = 400;
    const INITIAL_WORLD_HALF = 36000;
    const LOOK_SENSITIVITY = 0.02;

    // === STATE ===
    let gameState = 'menu';
    let playerRadius = START_RADIUS;
    let worldHalf = INITIAL_WORLD_HALF;
    let worldSize = worldHalf * 2;
    let score = 0;
    let objects = [];
    let player = null;
    let blackHoleMesh = null;
    let accretionGlow = null;
    let camera = null;
    let scene = null;
    let renderer = null;
    let rafId = null;
    let lastSpawn = 0;
    let growthCounter = 0;

    let moveInputX = 0, moveInputY = 0;
    let lookInputX = 0, lookInputY = 0;
    let playerYaw = 0;
    let playerPitch = 0;

    const objectTypes = [
      { name: 'asteroid', color: 0x555555, emissive: 0x222222, roughness: 0.9, metalness: 0.1, min: 0.3, max: 1.8, points: 1, emissiveIntensity: 1.8 },
      { name: 'planet', color: 0x44aa44, emissive: 0x113311, roughness: 0.7, metalness: 0.0, min: 1.9, max: 3.5, points: 2, emissiveIntensity: 1.8 },
      { name: 'oasis-planet', color: 0x3388dd, emissive: 0x114466, roughness: 0.6, metalness: 0.0, min: 2.0, max: 3.2, points: 3, emissiveIntensity: 1.8 },
      { name: 'gas-giant', color: 0x4444cc, emissive: 0x111144, roughness: 0.5, metalness: 0.2, min: 3.6, max: 6.0, points: 4, emissiveIntensity: 1.8 },
      { name: 'star', color: 0xffff66, emissive: 0x888800, roughness: 0.1, metalness: 0.9, emissiveIntensity: 3, min: 6.1, max: 12.0, points: 8 },
      { name: 'moving-asteroid', color: 0xaa8844, emissive: 0x332211, roughness: 0.85, metalness: 0.1, min: 0.5, max: 1.5, points: 1, emissiveIntensity: 1.8 },
      { name: 'black-hole', color: 0x000000, emissive: 0x050515, roughness: 0.1, metalness: 0.98, min: 2.0, max: 3.5, points: 0 }
    ];

    function dist3(a, b) {
      if (!a || !b) return Infinity;
      const ax = a.x !== undefined ? a.x : (a.position ? a.position.x : 0);
      const ay = a.y !== undefined ? a.y : (a.position ? a.position.y : 0);
      const az = a.z !== undefined ? a.z : (a.position ? a.position.z : 0);
      const bx = b.x !== undefined ? b.x : (b.position ? b.position.x : 0);
      const by = b.y !== undefined ? b.y : (b.position ? b.position.y : 0);
      const bz = b.z !== undefined ? b.z : (b.position ? b.position.z : 0);
      const dx = ax - bx;
      const dy = ay - by;
      const dz = az - bz;
      return dx*dx + dy*dy + dz*dz;
    }

    function safeRemove(obj) {
      if (!obj) return;
      try {
        if (obj.parent) obj.parent.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) obj.material.forEach(m => m?.dispose?.());
          else obj.material?.dispose?.();
        }
      } catch (e) { console.warn('Cleanup:', e); }
    }

    function createCosmicBackground() {
      const mwCount = 12000;
      const mwGeo = new THREE.BufferGeometry();
      const mwPos = new Float32Array(mwCount * 3);
      for (let i = 0; i < mwCount; i++) {
        const r = Math.sqrt(Math.random()) * worldSize * 0.4;
        const theta = Math.random() * Math.PI * 2;
        const z = (Math.random() - 0.5) * 300;
        mwPos[i * 3] = Math.cos(theta) * r;
        mwPos[i * 3 + 1] = z;
        mwPos[i * 3 + 2] = Math.sin(theta) * r;
      }
      mwGeo.setAttribute('position', new THREE.BufferAttribute(mwPos, 3));
      const mwMat = new THREE.PointsMaterial({ color: 0xf0f0aa, size: 3.5, transparent: true, opacity: 0.3, sizeAttenuation: true });
      const milkyWay = new THREE.Points(mwGeo, mwMat);
      scene.add(milkyWay);

      for (let g = 0; g < 3; g++) {
        const spiralCount = 4000;
        const spiralGeo = new THREE.BufferGeometry();
        const spiralPos = new Float32Array(spiralCount * 3);
        const offsetX = (Math.random() - 0.5) * worldSize * 0.8;
        const offsetZ = (Math.random() - 0.5) * worldSize * 0.8;
        for (let i = 0; i < spiralCount; i++) {
          const angle = Math.random() * Math.PI * 10;
          const r = Math.random() * worldSize * 0.3;
          const x = Math.cos(angle) * r;
          const z = Math.sin(angle) * r;
          const y = (Math.random() - 0.5) * 400;
          spiralPos[i * 3] = x + offsetX;
          spiralPos[i * 3 + 1] = y;
          spiralPos[i * 3 + 2] = z + offsetZ;
        }
        spiralGeo.setAttribute('position', new THREE.BufferAttribute(spiralPos, 3));
        const spiralMat = new THREE.PointsMaterial({ color: 0xddddff, size: 2.8, transparent: true, opacity: 0.35, sizeAttenuation: true });
        const spiralGalaxy = new THREE.Points(spiralGeo, spiralMat);
        scene.add(spiralGalaxy);
      }

      const nebulae = [
        { pos: new THREE.Vector3(-worldSize/3, 0, -worldSize/3), color: 0xff66aa, size: 15000 },
        { pos: new THREE.Vector3(worldSize/3, 0, worldSize/3), color: 0x66aaff, size: 12000 },
        { pos: new THREE.Vector3(0, worldSize/4, 0), color: 0x9966ff, size: 14000 },
        { pos: new THREE.Vector3(worldSize/2, worldSize/4, -worldSize/4), color: 0xff9966, size: 10000 }
      ];
      for (const n of nebulae) {
        const geo = new THREE.SphereGeometry(n.size, 48, 48);
        const mat = new THREE.MeshBasicMaterial({ color: n.color, transparent: true, opacity: 0.07 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(n.pos);
        scene.add(mesh);
      }

      const starCount = 100000;
      const starGeo = new THREE.BufferGeometry();
      const starPos = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        starPos[i * 3] = (Math.random() - 0.5) * worldSize * 2;
        starPos[i * 3 + 1] = (Math.random() - 0.5) * worldSize * 2;
        starPos[i * 3 + 2] = (Math.random() - 0.5) * worldSize * 2;
      }
      starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
      const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2.2, sizeAttenuation: true });
      const stars = new THREE.Points(starGeo, starMat);
      scene.add(stars);
    }

    function initThreeJS() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x080312);

      player = new THREE.Object3D();
      player.position.set(0, 0, 0);
      scene.add(player);

      blackHoleMesh = new THREE.Mesh(
        new THREE.SphereGeometry(START_RADIUS, 64, 64),
        new THREE.MeshStandardMaterial({
          color: 0x000000,
          emissive: 0x050515,
          roughness: 0.1,
          metalness: 0.98
        })
      );
      player.add(blackHoleMesh);

      const particleCount = 400;
      const particles = new THREE.BufferGeometry();
      const pos = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const colorsList = [0xb16ce9, 0x8a2be2, 0x5e17eb, 0x9a4cff];
      for (let i = 0; i < particleCount; i++) {
        const radius = 1.0 + Math.random() * 2.5;
        const angle1 = Math.random() * Math.PI * 2;
        const angle2 = Math.random() * Math.PI * 2;
        pos[i * 3] = Math.sin(angle1) * Math.cos(angle2) * radius;
        pos[i * 3 + 1] = Math.sin(angle2) * radius;
        pos[i * 3 + 2] = Math.cos(angle1) * Math.cos(angle2) * radius;
        const color = new THREE.Color(colorsList[Math.floor(Math.random() * colorsList.length)]);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
      }
      particles.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      const material = new THREE.PointsMaterial({
        size: 0.8,
        vertexColors: true,
        transparent: true,
        opacity: 0.92,
        sizeAttenuation: true
      });
      accretionGlow = new THREE.Points(particles, material);
      player.add(accretionGlow);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 80000);
      scene.add(camera);

      const canvas = document.querySelector('canvas');
      if (canvas) canvas.remove();
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      createCosmicBackground();
    }

    function cleanupScene() {
      if (player) {
        safeRemove(player);
        player = null;
        blackHoleMesh = null;
        accretionGlow = null;
      }
      objects.forEach(safeRemove);
      objects = [];
    }

    function getTypeBySize(size) {
      if (size <= 1.8) return objectTypes[0];
      if (size <= 3.2) {
        return Math.random() < 0.3 ? objectTypes[2] : objectTypes[1];
      }
      if (size <= 6.0) return objectTypes[3];
      if (size <= 12.0) return objectTypes[4];
      return objectTypes[0];
    }

    function createObjectAtPosition(pos, isEnemy = false, forcedSize = null) {
      let size = forcedSize;
      if (size === null) {
        if (isEnemy) {
          size = 2.0 + Math.random() * 1.5;
        } else {
          if (Math.random() < 0.4) {
            size = Math.random() * (playerRadius * 0.5);
          } else {
            size = 0.3 + Math.random() * 15;
          }
          if (size < 0.3) size = 0.3;
        }
      }

      const typeObj = isEnemy ? objectTypes[6] : getTypeBySize(size);
      const geometry = new THREE.SphereGeometry(size, 48, 48);
      const material = new THREE.MeshStandardMaterial({
        color: typeObj.color,
        emissive: typeObj.emissive,
        roughness: typeObj.roughness,
        metalness: typeObj.metalness,
        emissiveIntensity: typeObj.emissiveIntensity || 1
      });
      const obj = new THREE.Mesh(geometry, material);

      obj.userData = { 
        radius: size, 
        points: typeObj.points, 
        type: typeObj.name,
        isBlackHole: typeObj.name === 'black-hole',
        isMovingAsteroid: typeObj.name === 'moving-asteroid',
        velocity: null,
        wanderTimer: Math.random() * 10
      };

      obj.position.copy(pos);

      if (typeObj.name === 'black-hole') {
        const enemyGlow = accretionGlow.clone();
        enemyGlow.scale.setScalar(1.0);
        obj.add(enemyGlow);
      }

      if (typeObj.name === 'moving-asteroid') {
        const angle1 = Math.random() * Math.PI * 2;
        const angle2 = Math.random() * Math.PI * 2;
        obj.userData.velocity = new THREE.Vector3(
          Math.sin(angle1) * Math.cos(angle2),
          Math.sin(angle2),
          Math.cos(angle1) * Math.cos(angle2)
        ).multiplyScalar(60);
      }

      return obj;
    }

    function spawnNewObject(nearPlayer = false) {
      if (objects.length >= MAX_OBJECTS) return;
      
      let pos;
      if (nearPlayer) {
        const distance = 30 + Math.random() * 170;
        const angle1 = Math.random() * Math.PI * 2;
        const angle2 = Math.random() * Math.PI * 2;
        pos = new THREE.Vector3(
          Math.sin(angle1) * Math.cos(angle2) * distance,
          Math.sin(angle2) * distance,
          Math.cos(angle1) * Math.cos(angle2) * distance
        ).add(player.position);
      } else {
        pos = new THREE.Vector3(
          (Math.random() - 0.5) * (worldSize - 400),
          (Math.random() - 0.5) * (worldSize - 400),
          (Math.random() - 0.5) * (worldSize - 400)
        );
      }

      let size;
      if (Math.random() < 0.4) {
        size = Math.random() * (playerRadius * 0.5);
      } else {
        size = 0.3 + Math.random() * 15;
      }
      if (size < 0.3) size = 0.3;

      const obj = createObjectAtPosition(pos, false, size);
      scene.add(obj);
      objects.push(obj);
    }

    function spawnEnemyBlackHoles(count) {
      for (let i = 0; i < count; i++) {
        const pos = new THREE.Vector3(
          (Math.random() - 0.5) * (worldSize - 500),
          (Math.random() - 0.5) * (worldSize - 500),
          (Math.random() - 0.5) * (worldSize - 500)
        );
        const obj = createObjectAtPosition(pos, true);
        scene.add(obj);
        objects.push(obj);
      }
    }

    function updateCamera() {
      if (!camera || !player) return;
      const camDistance = 60 + playerRadius * 8;
      const camX = player.position.x - Math.sin(playerYaw) * Math.cos(playerPitch) * camDistance;
      const camY = player.position.y + Math.sin(playerPitch) * camDistance;
      const camZ = player.position.z - Math.cos(playerYaw) * Math.cos(playerPitch) * camDistance;
      camera.position.set(camX, camY, camZ);
      camera.lookAt(player.position);
    }

    function updateEnemyBlackHole(bh) {
      if (!bh || !bh.userData?.isBlackHole) return;
      let target = null;
      let minDist = Infinity;
      for (const obj of objects) {
        if (obj === bh || !obj.userData) continue;
        if (obj.userData.radius >= bh.userData.radius) continue;
        const d = dist3(bh.position, obj.position);
        if (d < minDist) {
          minDist = d;
          target = obj;
        }
      }
      if (!target && playerRadius < bh.userData.radius) {
        target = { position: player.position };
      }

      const speed = Math.min(100 + bh.userData.radius * 5, 300);
      if (target && target.position) {
        const dir = new THREE.Vector3().subVectors(target.position, bh.position).normalize();
        bh.position.add(dir.multiplyScalar(speed * 0.016));
      } else {
        bh.userData.wanderTimer += 0.016;
        const wx = Math.cos(bh.userData.wanderTimer) * 20;
        const wy = Math.sin(bh.userData.wanderTimer * 0.7) * 20;
        const wz = Math.cos(bh.userData.wanderTimer * 0.5) * 20;
        bh.position.add(new THREE.Vector3(wx, wy, wz));
      }

      const h = worldHalf;
      bh.position.x = Math.max(-h, Math.min(h, bh.position.x));
      bh.position.y = Math.max(-h, Math.min(h, bh.position.y));
      bh.position.z = Math.max(-h, Math.min(h, bh.position.z));
    }

    function gameLoop() {
      rafId = requestAnimationFrame(gameLoop);
      if (gameState !== 'playing' || !scene || !camera || !renderer) return;

      const dt = 0.016;

      if (accretionGlow) {
        const scale = playerRadius / START_RADIUS;
        accretionGlow.scale.setScalar(scale);
        const time = Date.now() * 0.001;
        accretionGlow.material.size = (0.6 + Math.sin(time * 2) * 0.2) * scale;
        accretionGlow.rotation.x += 0.01;
        accretionGlow.rotation.y += 0.015;
      }

      // === FLY-–£–ü–†–ê–í–õ–ï–ù–ò–ï ===
      if (Math.abs(moveInputX) > 0.01 || Math.abs(moveInputY) > 0.01) {
        const speed = Math.min(150 + playerRadius * 8, MAX_PLAYER_SPEED) * dt;

        const forward = new THREE.Vector3(
          -Math.sin(playerYaw) * Math.cos(playerPitch),
          Math.sin(playerPitch),
          -Math.cos(playerYaw) * Math.cos(playerPitch)
        );

        // üîß –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –≤–µ–∫—Ç–æ—Ä "–≤–ø—Ä–∞–≤–æ"
        const right = new THREE.Vector3(
          -Math.cos(playerYaw),   // ‚Üê –±—ã–ª–æ Math.cos(playerYaw)
          0,
          Math.sin(playerYaw)     // ‚Üê –±—ã–ª–æ -Math.sin(playerYaw)
        );

        player.position.add(forward.multiplyScalar(moveInputY * speed));
        player.position.add(right.multiplyScalar(moveInputX * speed)); // ‚Üê –±–µ–∑ –∏–Ω–≤–µ—Ä—Å–∏–∏

        const h = worldHalf;
        player.position.x = Math.max(-h, Math.min(h, player.position.x));
        player.position.y = Math.max(-h, Math.min(h, player.position.y));
        player.position.z = Math.max(-h, Math.min(h, player.position.z));
      }

      // === –£–ü–†–ê–í–õ–ï–ù–ò–ï –í–ó–ì–õ–Ø–î–û–ú === (–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ‚Äî —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ)
      if (Math.abs(lookInputX) > 0.01 || Math.abs(lookInputY) > 0.01) {
        playerYaw += lookInputX * LOOK_SENSITIVITY;
        playerPitch = THREE.MathUtils.clamp(
          playerPitch + lookInputY * LOOK_SENSITIVITY,
          -Math.PI / 2 + 0.1,
          Math.PI / 2 - 0.1
        );
      }

      if (player && gameState === 'playing') {
        const coordsEl = document.getElementById('coordinates');
        if (coordsEl) {
          coordsEl.textContent = `X: ${Math.round(player.position.x)}  Y: ${Math.round(player.position.y)}  Z: ${Math.round(player.position.z)}`;
        }
      }

      updateCamera();

      const suctionRadius = Math.min(800, 300 + playerRadius * 10);
      const maxPull = 15 + playerRadius * 0.5;

      for (const obj of objects) {
        if (!obj || !obj.userData) continue;
        if (obj.userData.isBlackHole) continue;
        if (obj.userData.radius >= playerRadius) continue;

        const d = Math.sqrt(dist3(player.position, obj.position));
        if (d < suctionRadius && d > 0.1) {
          const pullStrength = (1 - d / suctionRadius) * maxPull;
          const dir = new THREE.Vector3().subVectors(player.position, obj.position).normalize();
          obj.position.add(dir.multiplyScalar(pullStrength * dt));
        }
      }

      for (let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        if (!obj || !obj.userData || !obj.position) continue;

        if (obj.userData.isMovingAsteroid && obj.userData.velocity) {
          obj.position.add(obj.userData.velocity.clone().multiplyScalar(dt));
          const h = worldHalf;
          if (Math.abs(obj.position.x) > h) obj.position.x = -obj.position.x;
          if (Math.abs(obj.position.y) > h) obj.position.y = -obj.position.y;
          if (Math.abs(obj.position.z) > h) obj.position.z = -obj.position.z;
        }

        if (obj.userData.isBlackHole) {
          updateEnemyBlackHole(obj);
        }
      }

      for (let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        if (!obj || !obj.userData) continue;
        const d2 = dist3(player.position, obj.position);
        const radiusSum = playerRadius + obj.userData.radius;
        if (d2 < radiusSum * radiusSum) {
          if (playerRadius > obj.userData.radius) {
            safeRemove(obj);
            objects.splice(i, 1);
            score += obj.userData.points || 0;
            playerRadius += obj.userData.radius * 0.2;
            if (blackHoleMesh) {
              blackHoleMesh.scale.setScalar(playerRadius / START_RADIUS);
            }
            growthCounter++;
            if (growthCounter >= 5) {
              worldHalf += 500;
              worldSize = worldHalf * 2;
              growthCounter = 0;
            }
            document.getElementById('score').textContent = score;
            document.getElementById('size').textContent = playerRadius.toFixed(1);
            document.getElementById('universe').textContent = `${Math.round(worldSize)}¬≥`;

            spawnNewObject(Math.random() < 0.8);
          } else if (obj.userData.isBlackHole) {
            showGameOver();
            return;
          }
        }
      }

      const now = performance.now();
      if (objects.length < MAX_OBJECTS && now - lastSpawn > SPAWN_INTERVAL) {
        spawnNewObject(Math.random() < 0.6);
        lastSpawn = now;
      }

      renderer.render(scene, camera);
    }

    // === –£–ü–†–ê–í–õ–ï–ù–ò–ï ===
    function showJoystick(x, y, type) {
      const el = document.getElementById(type === 'move' ? 'joystick' : 'lookJoystick');
      if (el) {
        el.style.left = (x - 42) + 'px';
        el.style.top = (y - 42) + 'px';
        el.style.display = 'block';
      }
    }
    function updateJoystick(x, y, baseX, baseY, type) {
      const dx = x - baseX;
      const dy = y - baseY;
      const maxDist = 42;
      const dist = Math.hypot(dx, dy);
      let ix = 0, iy = 0;
      if (dist > maxDist) {
        const angle = Math.atan2(dy, dx);
        ix = Math.cos(angle);
        iy = Math.sin(angle);
      } else {
        ix = dx / maxDist;
        iy = dy / maxDist;
      }

      const inner = document.getElementById(type === 'move' ? 'joystick-inner' : 'lookJoystick-inner');
      if (inner) {
        inner.style.left = (42 + ix * maxDist - 16) + 'px';
        inner.style.top = (42 + iy * maxDist - 16) + 'px';
      }

      if (type === 'move') {
        moveInputX = ix;
        moveInputY = iy;
      } else {
        lookInputX = ix;
        lookInputY = iy;
      }
    }
    function hideJoystick(type) {
      const el = document.getElementById(type === 'move' ? 'joystick' : 'lookJoystick');
      if (el) el.style.display = 'none';
      if (type === 'move') {
        moveInputX = 0; moveInputY = 0;
      } else {
        lookInputX = 0; lookInputY = 0;
      }
    }

    function startGame() {
      cleanupScene();
      
      playerRadius = START_RADIUS;
      worldHalf = INITIAL_WORLD_HALF;
      worldSize = worldHalf * 2;
      score = 0;
      growthCounter = 0;
      playerYaw = 0;
      playerPitch = 0;
      document.getElementById('score').textContent = '0';
      document.getElementById('size').textContent = START_RADIUS.toFixed(1);
      document.getElementById('universe').textContent = `${worldSize}¬≥`;
      document.getElementById('ui').classList.remove('visible');
      document.getElementById('coordinates').textContent = 'X: 0  Y: 0  Z: 0';
      
      initThreeJS();

      for (let i = 0; i < 10; i++) {
        spawnNewObject(true);
      }
      for (let i = 0; i < MAX_OBJECTS - 10; i++) {
        spawnNewObject(false);
      }
      spawnEnemyBlackHoles(1 + Math.floor(Math.random() * 3));

      const canvas = renderer.domElement;
      let lookTouchId = null;
      let moveTouchId = null;

      canvas.addEventListener('touchstart', (e) => {
        if (gameState !== 'playing') return;
        for (let i = 0; i < e.touches.length; i++) {
          const touch = e.touches[i];
          if (touch.clientY < window.innerHeight / 2) {
            if (lookTouchId === null) {
              lookTouchId = touch.identifier;
              showJoystick(touch.clientX, touch.clientY, 'look');
            }
          } else {
            if (moveTouchId === null) {
              moveTouchId = touch.identifier;
              showJoystick(touch.clientX, touch.clientY, 'move');
            }
          }
        }
        e.preventDefault();
      }, { passive: false });

      canvas.addEventListener('touchmove', (e) => {
        if (gameState !== 'playing') return;
        for (let i = 0; i < e.touches.length; i++) {
          const touch = e.touches[i];
          if (touch.identifier === lookTouchId) {
            const el = document.getElementById('lookJoystick');
            if (el) {
              const rect = el.getBoundingClientRect();
              updateJoystick(touch.clientX, touch.clientY, rect.left + 42, rect.top + 42, 'look');
            }
          } else if (touch.identifier === moveTouchId) {
            const el = document.getElementById('joystick');
            if (el) {
              const rect = el.getBoundingClientRect();
              updateJoystick(touch.clientX, touch.clientY, rect.left + 42, rect.top + 42, 'move');
            }
          }
        }
        e.preventDefault();
      }, { passive: false });

      const onTouchEnd = (e) => {
        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.identifier === lookTouchId) {
            lookTouchId = null;
            hideJoystick('look');
          } else if (touch.identifier === moveTouchId) {
            moveTouchId = null;
            hideJoystick('move');
          }
        }
      };
      canvas.addEventListener('touchend', onTouchEnd);
      canvas.addEventListener('touchcancel', onTouchEnd);

      gameState = 'playing';
      document.getElementById('menu').classList.add('hidden');
      document.getElementById('gameOver').classList.remove('visible');
      setTimeout(() => {
        document.getElementById('ui').classList.add('visible');
        document.getElementById('coordinates').classList.add('visible');
      }, 300);

      if (rafId) cancelAnimationFrame(rafId);
      gameLoop();
    }

    function showGameOver() {
      gameState = 'gameOver';
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOver').classList.add('visible');
    }

    function backToMenu() {
      gameState = 'menu';
      if (rafId) cancelAnimationFrame(rafId);
      cleanupScene();
      if (renderer) {
        renderer.domElement.remove();
        renderer.dispose();
        renderer = null;
      }
      scene = null;
      camera = null;
      document.getElementById('gameOver').classList.remove('visible');
      document.getElementById('menu').classList.remove('hidden');
    }

    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);
    document.getElementById('menuBtn').addEventListener('click', backToMenu);

    window.addEventListener('resize', () => {
      if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });
  </script>
</body>
</html>
