<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>–¢—Ä–∏ –≤ —Ä—è–¥</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;user-select:none;touch-action:manipulation}
body{background:linear-gradient(135deg,#1a2a6c,#b21f1f,#1a2a6c);background-size:400% 400%;animation:gradientBG 15s ease infinite;display:flex;justify-content:center;align-items:center;height:100vh;font-family:Segoe UI,sans-serif;overflow:hidden;position:relative}
@keyframes gradientBG{0%,100%{background-position:0% 50%}50%{background-position:100% 50%}}
body::before,body::after{content:'';position:absolute;border-radius:50%;background:radial-gradient(circle,rgba(255,255,255,0.15) 0%,transparent 70%);z-index:-2}
body::before{top:10%;left:15%;width:200px;height:200px}
body::after{bottom:15%;right:20%;width:350px;height:350px}
#gameCanvas{border-radius:16px;box-shadow:0 12px 40px rgba(0,0,0,0.4),inset 0 0 20px rgba(255,255,255,0.1);display:block;background:rgba(10,15,30,0.4);backdrop-filter:blur(4px);border:1px solid rgba(255,255,255,0.08)}
#ui{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}
.screen{display:none;flex-direction:column;align-items:center;justify-content:center;width:100%;height:100%;padding:20px}
.screen.active{display:flex}
.screen button{pointer-events:auto;padding:16px 36px;font-size:20px;border:none;border-radius:14px;cursor:pointer;margin:14px 0;width:260px;font-weight:bold;background:linear-gradient(135deg,#6a11cb,#2575fc);color:white;box-shadow:0 6px 20px rgba(37,117,252,0.4);transition:all .25s cubic-bezier(.175,.885,.32,1.275)}
.screen button:hover{transform:translateY(-3px);box-shadow:0 8px 25px rgba(37,117,252,.6)}
.screen button:active{transform:translateY(1px)}
.level-btn{background:linear-gradient(135deg,#ff416c,#ff4b2b);box-shadow:0 6px 20px rgba(255,75,43,.4)}
.level-btn:hover{box-shadow:0 8px 25px rgba(255,75,43,.6)}
.back-icon{position:absolute;top:20px;right:20px;width:50px;height:50px;border-radius:50%;background:rgba(0,0,0,.3);backdrop-filter:blur(4px);display:flex;align-items:center;justify-content:center;color:white;font-size:24px;cursor:pointer;pointer-events:auto;box-shadow:0 4px 12px rgba(0,0,0,.2);z-index:10}
.bomb-icon{position:absolute;bottom:60px;right:20px;width:50px;height:50px;border-radius:50%;background:rgba(255,87,0,.8);display:flex;align-items:center;justify-content:center;color:white;font-size:20px;cursor:pointer;pointer-events:auto;box-shadow:0 4px 12px rgba(255,87,0,.4);z-index:10}
.bomb-icon:disabled{opacity:.4;cursor:not-allowed}
h2{font-size:36px;margin-bottom:30px;color:white;text-shadow:0 2px 6px rgba(0,0,0,.3);letter-spacing:1px}
.hud{position:absolute;top:20px;left:0;width:100%;display:flex;justify-content:center;padding:0 100px;pointer-events:none}
.hud-item{background:rgba(0,0,0,.25);backdrop-filter:blur(6px);padding:8px 16px;border-radius:12px;color:white;font-weight:bold;font-size:16px;box-shadow:0 4px 12px rgba(0,0,0,.2);margin:0 8px}
.timer-bar{position:absolute;bottom:20px;left:20px;right:20px;height:10px;background:rgba(0,0,0,.2);border-radius:5px;overflow:hidden;z-index:5}
.timer-fill{height:100%;background:linear-gradient(90deg,#ff416c,#ff4b2b);width:100%;transition:width .1s linear}
.result-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);display:flex;flex-direction:column;justify-content:center;align-items:center;color:white;font-size:32px;font-weight:bold;z-index:10;pointer-events:none;opacity:0;transition:opacity .4s ease}
.result-overlay.show{opacity:1;pointer-events:auto}
.result-overlay button{margin-top:30px;background:linear-gradient(135deg,#00c9ff,#92fe9d);box-shadow:0 6px 20px rgba(0,201,255,.4)}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
  <div id="mainMenu" class="screen active">
    <h2>–¢—Ä–∏ –≤ —Ä—è–¥</h2>
    <button id="btnLevel1" class="level-btn">–£—Ä–æ–≤–µ–Ω—å 1</button>
    <button id="btnLevel2" class="level-btn">–£—Ä–æ–≤–µ–Ω—å 2</button>
    <button id="btnLevel3" class="level-btn">–£—Ä–æ–≤–µ–Ω—å 3</button>
    <button id="btnLevel4" class="level-btn">–£—Ä–æ–≤–µ–Ω—å 4</button>
    <button id="btnLevel5" class="level-btn">–£—Ä–æ–≤–µ–Ω—å 5</button>
    <button id="btnExit">–í—ã—Ö–æ–¥</button>
  </div>
  <div id="inGameUI" class="screen">
    <div class="hud">
      <div class="hud-item" id="score">0</div>
      <div class="hud-item" id="target">100</div>
      <div class="hud-item" id="time">60</div>
    </div>
    <div class="timer-bar"><div class="timer-fill" id="timerFill"></div></div>
    <div class="back-icon" id="btnBackInGame">üè†</div>
    <div class="bomb-icon" id="bombBtn">üí£</div>
  </div>
  <div class="result-overlay" id="resultOverlay">
    <div id="resultText">–ü–æ–±–µ–¥–∞!</div>
    <button id="btnRestart">–í –º–µ–Ω—é</button>
  </div>
</div>
<script>
const LEVELS=[{time:60,target:100},{time:50,target:150},{time:40,target:220},{time:30,target:300},{time:20,target:400}],COLS=8,ROWS=8,COLORS=['#FF4C4C','#4CFF4C','#4C4CFF','#FFD700','#FF4CFF','#4CFFFF','#FF9A4C','#C44CFF'],CELL_PAD=3,ANIM_DUR=300,DROP_DUR=500,MAX_CHAIN=5;
const canvas=document.getElementById('gameCanvas'),ctx=canvas.getContext('2d'),scoreEl=document.getElementById('score'),targetEl=document.getElementById('target'),timeEl=document.getElementById('time'),timerFill=document.getElementById('timerFill'),bombBtn=document.getElementById('bombBtn'),resultOverlay=document.getElementById('resultOverlay'),resultText=document.getElementById('resultText');
let state={mode:'menu',grid:[],sel:null,offX:0,offY:0,cellSize:0,score:0,bombs:0,target:0,timeLeft:0,timerId:null,level:0,usingBomb:false};

function resizeCanvas(){const s=Math.min(window.innerWidth,window.innerHeight)*0.85;canvas.width=canvas.height=s;state.cellSize=s/COLS;state.offX=(s-COLS*state.cellSize)/2;state.offY=(s-ROWS*state.cellSize)/2;if(state.mode==='playing')drawGrid()}
window.addEventListener('resize',resizeCanvas);resizeCanvas();

function genCleanGrid(){let g,a=0;do{g=Array(ROWS).fill().map(()=>Array(COLS).fill().map(()=>COLORS[Math.floor(Math.random()*COLORS.length)]));a++}while(findMatches(g).size>0&&a<200);return g}
function findMatches(grid){const m=new Set();for(let r=0;r<ROWS;r++){let c=1;for(let i=1;i<COLS;i++){if(grid[r][i]===grid[r][i-1])c++;else{if(c>=3)for(let j=i-c;j<i;j++)m.add(`${r},${j}`);c=1}}if(c>=3)for(let j=COLS-c;j<COLS;j++)m.add(`${r},${j}`)}for(let c=0;c<COLS;c++){let c2=1;for(let r=1;r<ROWS;r++){if(grid[r][c]===grid[r-1][c])c2++;else{if(c2>=3)for(let j=r-c2;j<r;j++)m.add(`${j},${c}`);c2=1}}if(c2>=3)for(let j=ROWS-c2;j<ROWS;j++)m.add(`${j},${c}`)}return m}
function drawGrid(){ctx.clearRect(0,0,canvas.width,canvas.height);for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){if(state.grid[r][c]===null)continue;const x=state.offX+c*state.cellSize,y=state.offY+r*state.cellSize,sz=state.cellSize-CELL_PAD*2,sel=state.sel&&state.sel.row===r&&state.sel.col===c,sc=sel?1.15:1;ctx.save();ctx.translate(x+state.cellSize/2,y+state.cellSize/2);ctx.scale(sc,sc);ctx.translate(-state.cellSize/2,-state.cellSize/2);const col=state.grid[r][c],grad=ctx.createRadialGradient(state.cellSize/2,state.cellSize/2,2,state.cellSize/2,state.cellSize/2,sz/2);grad.addColorStop(0,col);grad.addColorStop(1,shade(col,-30));ctx.fillStyle=grad;ctx.fillRect(CELL_PAD,CELL_PAD,sz,sz);ctx.strokeStyle='rgba(255,255,255,0.3)';ctx.lineWidth=2;ctx.strokeRect(CELL_PAD,CELL_PAD,sz,sz);ctx.restore()}}
function shade(c,p){let R=parseInt(c.slice(1,3),16),G=parseInt(c.slice(3,5),16),B=parseInt(c.slice(5,7),16);R=Math.min(255,Math.max(0,R+Math.round((p/100)*R)));G=Math.min(255,Math.max(0,G+Math.round((p/100)*G)));B=Math.min(255,Math.max(0,B+Math.round((p/100)*B)));return`#${R.toString(16).padStart(2,'0')}${G.toString(16).padStart(2,'0')}${B.toString(16).padStart(2,'0')}`}

function animateRemoval(set){return new Promise(res=>{const st=performance.now();(function l(now){const p=Math.min((now-st)/ANIM_DUR,1),sc=1-p,a=1-p;drawGrid();for(const pos of set){const [r,c]=pos.split(',').map(Number),x=state.offX+c*state.cellSize+CELL_PAD,y=state.offY+r*state.cellSize+CELL_PAD,sz=(state.cellSize-CELL_PAD*2)*sc;ctx.save();ctx.globalAlpha=a;ctx.translate(x+(state.cellSize-CELL_PAD*2)/2,y+(state.cellSize-CELL_PAD*2)/2);ctx.scale(sc,sc);ctx.translate(-(state.cellSize-CELL_PAD*2)/2,-(state.cellSize-CELL_PAD*2)/2);ctx.fillStyle=state.grid[r][c];ctx.fillRect(CELL_PAD,CELL_PAD,state.cellSize-CELL_PAD*2,state.cellSize-CELL_PAD*2);ctx.strokeStyle='rgba(255,255,255,0.4)';ctx.lineWidth=2;ctx.strokeRect(CELL_PAD,CELL_PAD,state.cellSize-CELL_PAD*2,state.cellSize-CELL_PAD*2);ctx.restore()}if(p<1)requestAnimationFrame(l);else res()})()})}
async function animateDrop(){for(let c=0;c<COLS;c++){let tR=ROWS-1;for(let r=ROWS-1;r>=0;r--){if(state.grid[r][c]!==null){if(r!==tR){state.grid[tR][c]=state.grid[r][c];state.grid[r][c]=null}tR--}}}const drops=[];for(let c=0;c<COLS;c++)for(let r=0;r<ROWS;r++)if(state.grid[r][c]===null){drops.push({row:r,col:c,color:COLORS[Math.floor(Math.random()*COLORS.length)]});state.grid[r][c]=drops[drops.length-1].color}const st=performance.now();return new Promise(res=>{(function f(now){const t=now-st,p=Math.min(t/DROP_DUR,1);ctx.clearRect(0,0,canvas.width,canvas.height);for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){if(state.grid[r][c]===null)continue;const x=state.offX+c*state.cellSize,y=state.offY+r*state.cellSize,sz=state.cellSize-CELL_PAD*2,grad=ctx.createRadialGradient(state.cellSize/2,state.cellSize/2,2,state.cellSize/2,state.cellSize/2,sz/2);grad.addColorStop(0,state.grid[r][c]);grad.addColorStop(1,shade(state.grid[r][c],-30));ctx.fillStyle=grad;ctx.fillRect(x+CELL_PAD,y+CELL_PAD,sz,sz);ctx.strokeStyle='rgba(255,255,255,0.3)';ctx.lineWidth=2;ctx.strokeRect(x+CELL_PAD,y+CELL_PAD,sz,sz)}for(const d of drops){const fY=state.offY+d.row*state.cellSize,sY=state.offY-state.cellSize,cY=sY+(fY-sY)*p,x=state.offX+d.col*state.cellSize,sz=state.cellSize-CELL_PAD*2;ctx.save();ctx.globalAlpha=p;const grad=ctx.createRadialGradient(state.cellSize/2,state.cellSize/2,2,state.cellSize/2,state.cellSize/2,sz/2);grad.addColorStop(0,d.color);grad.addColorStop(1,shade(d.color,-30));ctx.fillStyle=grad;ctx.fillRect(x+CELL_PAD,cY+CELL_PAD,sz,sz);ctx.strokeStyle='rgba(255,255,255,0.3)';ctx.lineWidth=2;ctx.strokeRect(x+CELL_PAD,cY+CELL_PAD,sz,sz);ctx.restore()}if(p<1)requestAnimationFrame(f);else res()})()})}

function areNeighbors(a,b){const dr=Math.abs(a.row-b.row),dc=Math.abs(a.col-b.col);return(dr===1&&dc===0)||(dr===0&&dc===1)}
function calcScore(set){const v=new Set(),g=[];for(const pos of set){if(v.has(pos))continue;const [r,c]=pos.split(',').map(Number),_g=[pos];v.add(pos);for(let cc=c+1;cc<COLS&&set.has(`${r},${cc}`)&&state.grid[r][cc]===state.grid[r][c];cc++){_g.push(`${r},${cc}`);v.add(`${r},${cc}`)}for(let cc=c-1;cc>=0&&set.has(`${r},${cc}`)&&state.grid[r][cc]===state.grid[r][c];cc--){_g.push(`${r},${cc}`);v.add(`${r},${cc}`)}if(_g.length>=3)g.push(_g)}v.clear();for(const pos of set){if(v.has(pos))continue;const [r,c]=pos.split(',').map(Number),_g=[pos];v.add(pos);for(let rr=r+1;rr<ROWS&&set.has(`${rr},${c}`)&&state.grid[rr][c]===state.grid[r][c];rr++){_g.push(`${rr},${c}`);v.add(`${rr},${c}`)}for(let rr=r-1;rr>=0&&set.has(`${rr},${c}`)&&state.grid[rr][c]===state.grid[r][c];rr--){_g.push(`${rr},${c}`);v.add(`${rr},${c}`)}if(_g.length>=3)g.push(_g)}let t=0,u=[];outer:for(const _g of g){for(const ug of u)if(ug.includes(_g[0]))continue outer;u.push(_g)}for(const _g of u)t+=_g.length*2;return t}
function updateBombs(){const n=Math.floor(state.score/15);if(n!==state.bombs){state.bombs=n;bombBtn.textContent='üí£'+n;bombBtn.disabled=n<=0}}
async function trySwap(a,b){if(!areNeighbors(a,b))return false;[state.grid[a.row][a.col],state.grid[b.row][b.col]]=[state.grid[b.row][b.col],state.grid[a.row][a.col]];const m=findMatches(state.grid);if(m.size===0){[state.grid[a.row][a.col],state.grid[b.row][b.col]]=[state.grid[b.row][b.col],state.grid[a.row][a.col]];return false}for(const pos of m){const [r,c]=pos.split(',').map(Number);state.grid[r][c]=null}const add=calcScore(m);state.score+=add;scoreEl.textContent=state.score;updateBombs();await animateRemoval(m);await animateDrop();let next=findMatches(state.grid),cc=0;while(next.size>0&&cc<MAX_CHAIN){for(const pos of next){const [r,c]=pos.split(',').map(Number);state.grid[r][c]=null}const a2=calcScore(next);state.score+=a2;scoreEl.textContent=state.score;updateBombs();await animateRemoval(next);await animateDrop();next=findMatches(state.grid);cc++}drawGrid();if(state.score>=state.target)endGame(true);return true}
function useBomb(cell){if(state.bombs<=0)return;state.bombs--;bombBtn.textContent='üí£'+state.bombs;bombBtn.disabled=state.bombs<=0;const r=cell.row,c=cell.col;for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){const nr=r+dr,nc=c+dc;if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS)state.grid[nr][nc]=null}for(let c=0;c<COLS;c++){const col=[];for(let r=ROWS-1;r>=0;r--)if(state.grid[r][c]!==null)col.push(state.grid[r][c]);while(col.length<ROWS)col.push(COLORS[Math.floor(Math.random()*COLORS.length)]);for(let r=0;r<ROWS;r++)state.grid[ROWS-1-r][c]=col[r]}drawGrid()}
function getCell(x,y){const rx=x-state.offX,ry=y-state.offY;if(rx<0||ry<0||rx>=COLS*state.cellSize||ry>=ROWS*state.cellSize)return null;return{col:Math.floor(rx/state.cellSize),row:Math.floor(ry/state.cellSize)}}
function handleInteraction(x,y){if(state.mode!=='playing')return;const rect=canvas.getBoundingClientRect(),cx=x-rect.left,cy=y-rect.top,cell=getCell(cx,cy);if(!cell){if(state.sel){state.sel=null;drawGrid()}return}if(state.usingBomb){state.usingBomb=false;useBomb(cell);return}if(state.sel===null){state.sel=cell;drawGrid()}else{if(state.sel.row===cell.row&&state.sel.col===cell.col){state.sel=null;drawGrid()}else{const f=state.sel;state.sel=null;trySwap(f,cell).then(ok=>{if(!ok)drawGrid()})}}}
function startTimer(){if(state.timerId)clearInterval(state.timerId);state.timerId=setInterval(()=>{state.timeLeft--;timeEl.textContent=state.timeLeft;timerFill.style.width=(state.timeLeft/LEVELS[state.level].time*100)+'%';if(state.timeLeft<=0)endGame(false)},1000)}
function endGame(win){if(state.timerId)clearInterval(state.timerId);state.timerId=null;state.mode='menu';resultText.textContent=win?'–ü–æ–±–µ–¥–∞! üéâ':'–í—Ä–µ–º—è –≤—ã—à–ª–æ! ‚è≥';resultOverlay.classList.add('show')}
function startLevel(idx){const lvl=LEVELS[idx];state.mode='playing';state.level=idx;state.grid=genCleanGrid();state.sel=null;state.score=0;state.bombs=0;state.target=lvl.target;state.timeLeft=lvl.time;state.usingBomb=false;scoreEl.textContent='0';targetEl.textContent=lvl.target;timeEl.textContent=lvl.time;bombBtn.textContent='üí£0';bombBtn.disabled=true;timerFill.style.width='100%';document.querySelectorAll('.screen').forEach(e=>e.classList.remove('active'));document.getElementById('inGameUI').classList.add('active');drawGrid();startTimer()}
function resetGame(){if(state.timerId)clearInterval(state.timerId);state.timerId=null;state.mode='menu';state.usingBomb=false;state.grid=[];state.sel=null;state.score=0;state.bombs=0;state.target=0;state.timeLeft=0;state.level=0}

canvas.addEventListener('click',e=>handleInteraction(e.clientX,e.clientY));
canvas.addEventListener('touchstart',e=>{if(e.touches.length===1){e.preventDefault();const t=e.touches[0];handleInteraction(t.clientX,t.clientY)}},{passive:false});
for(let i=0;i<5;i++)document.getElementById(`btnLevel${i+1}`).addEventListener('click',()=>startLevel(i));
document.getElementById('btnExit').addEventListener('click',()=>alert('–í—ã—Ö–æ–¥ (–∑–∞–≥–ª—É—à–∫–∞)'));
document.getElementById('btnBackInGame').addEventListener('click',()=>{resetGame();document.getElementById('mainMenu').classList.add('active');document.getElementById('inGameUI').classList.remove('active')});
bombBtn.addEventListener('click',()=>{if(state.bombs>0)state.usingBomb=true});
document.getElementById('btnRestart').addEventListener('click',()=>{resetGame();resultOverlay.classList.remove('show');document.getElementById('mainMenu').classList.add('active')});
</script>
</body>
</html>
