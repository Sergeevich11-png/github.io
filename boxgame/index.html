<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>3D Комната — 50×25×50</title>
<style>
body, html {
margin: 0;
padding: 0;
overflow: hidden;
width: 100%;
height: 100%;
background: #000;
touch-action: none;
font-family: Arial, sans-serif;
}
#debug {
position: absolute;
top: 10px;
left: 10px;
color: white;
font-family: monospace;
font-size: 14px;
z-index: 10;
background: rgba(0,0,0,0.6);
padding: 6px;
border-radius: 4px;
}
#joystick {
position: absolute;
bottom: 20px;
left: 20px;
width: 120px;
height: 120px;
border: 2px solid white;
border-radius: 50%;
display: none;
touch-action: none;
}
#stick {
position: absolute;
width: 40px;
height: 40px;
background: white;
border-radius: 50%;
top: 40px;
left: 40px;
}
#mainMenu {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
text-align: center;
z-index: 100;
color: white;
}
#mainMenu button {
display: block;
width: 200px;
margin: 16px auto;
padding: 16px;
font-size: 20px;
background: #333;
color: white;
border: 2px solid #666;
border-radius: 10px;
cursor: pointer;
}
#pauseBtn {
position: absolute;
top: 15px;
right: 15px;
z-index: 90;
padding: 8px 16px;
background: rgba(0,0,0,0.6);
color: white;
border: none;
border-radius: 6px;
display: none;
}
#pauseMenu {
position: absolute;
top: 0; left: 0; right: 0; bottom: 0;
background: rgba(0,0,0,0.85);
display: none;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 200;
color: white;
}
#pauseMenu button {
width: 180px;
padding: 14px;
margin: 12px;
font-size: 18px;
background: #444;
color: white;
border: 1px solid #777;
border-radius: 8px;
}
#cubeUI {
position: absolute;
bottom: 160px;
left: 20px;
width: 40px;
height: 40px;
background: #ff9800;
border: 2px solid white;
border-radius: 4px;
display: none;
z-index: 95;
}
#confirmBox {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: rgba(0,0,0,0.8);
padding: 20px;
border-radius: 10px;
text-align: center;
z-index: 300;
color: white;
display: none;
}
#confirmBox button {
margin: 8px;
padding: 8px 16px;
background: #444;
border: none;
border-radius: 6px;
cursor: pointer;
}
</style>
</head>
<body>
<div id="mainMenu">
<button id="playBtn">Играть</button>
<button id="exitBtn">Выйти</button>
</div>
<button id="pauseBtn">Пауза</button>
<div id="pauseMenu">
<button id="resumeBtn">Продолжить</button>
<button id="backToMenuBtn">В главное меню</button>
</div>
<div id="debug">Загрузка...</div>
<div id="joystick"><div id="stick"></div></div>
<div id="cubeUI"></div>
<div id="confirmBox">
<p id="confirmText">Взять?</p>
<button id="confirmYes">Да</button>
<button id="confirmNo">Нет</button>
</div>
<script src="https://unpkg.com/three@0.160.1/build/three.min.js"></script>
<script>
let isGameActive = false;
let gameInitialized = false;
const mainMenu = document.getElementById('mainMenu');
const pauseBtn = document.getElementById('pauseBtn');
const pauseMenu = document.getElementById('pauseMenu');
const cubeUI = document.getElementById('cubeUI');
const confirmBox = document.getElementById('confirmBox');
const confirmText = document.getElementById('confirmText');
const confirmYes = document.getElementById('confirmYes');
const confirmNo = document.getElementById('confirmNo');

function initGame() {
if (gameInitialized) return;

const WORLD_SIZE_X = 50;
const WORLD_SIZE_Y = 25;
const WORLD_SIZE_Z = 50;
const PLAYER_HEIGHT = 3.2;
const START_POS = { x: -20, y: PLAYER_HEIGHT, z: 20 };
const MOVE_SPEED = 0.0125;
const LOOK_SENSITIVITY = 0.002;
const WALL_MARGIN = 0.5;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.5, 1000);
camera.position.set(START_POS.x, START_POS.y, START_POS.z);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.05);
scene.add(ambientLight);

const spotLight = new THREE.SpotLight(0xfff0b3, 9.5);
spotLight.position.set(0, WORLD_SIZE_Y, 0);
spotLight.angle = Math.atan(28.6 / WORLD_SIZE_Y);
spotLight.penumbra = 0.3;
spotLight.decay = 1;
spotLight.distance = 60;
scene.add(spotLight);

let isLampOn = true;

const wallColor = 0xC8C8C8;
const ceilingColor = 0xF5F0E6;
const floorDark = 0x5D4037;
const floorLight = 0x8D6E63;

function createConcreteTexture(size = 128) {
	const canvas = document.createElement('canvas');
	canvas.width = size;
	canvas.height = size;
	const ctx = canvas.getContext('2d');
	ctx.fillStyle = '#C8C8C8';
	ctx.fillRect(0, 0, size, size);
	const imageData = ctx.getImageData(0, 0, size, size);
	const data = imageData.data;
	for (let i = 0; i < data.length; i += 4) {
		let noise = (Math.random() - 0.5) * 15;
		if (Math.random() > 0.8) noise *= 2;
		data[i]     = Math.min(255, Math.max(0, 0xC8 + noise));
		data[i + 1] = Math.min(255, Math.max(0, 0xC8 + noise));
		data[i + 2] = Math.min(255, Math.max(0, 0xC8 + noise));
		data[i + 3] = 255;
	}
	ctx.putImageData(imageData, 0, 0);
	const texture = new THREE.CanvasTexture(canvas);
	texture.wrapS = THREE.RepeatWrapping;
	texture.wrapT = THREE.RepeatWrapping;
	texture.repeat.set(6, 6);
	return texture;
}

const concreteTexture = createConcreteTexture();

const walls = [
{ pos: [0, WORLD_SIZE_Y/2, -WORLD_SIZE_Z/2], size: [WORLD_SIZE_X, WORLD_SIZE_Y, 1], color: wallColor },
{ pos: [0, WORLD_SIZE_Y/2,  WORLD_SIZE_Z/2], size: [WORLD_SIZE_X, WORLD_SIZE_Y, 1], color: wallColor },
{ pos: [-WORLD_SIZE_X/2, WORLD_SIZE_Y/2, 0], size: [1, WORLD_SIZE_Y, WORLD_SIZE_Z], color: wallColor },
{ pos: [ WORLD_SIZE_X/2, WORLD_SIZE_Y/2, 0], size: [1, WORLD_SIZE_Y, WORLD_SIZE_Z], color: wallColor },
{ pos: [0, 0, 0], size: [WORLD_SIZE_X, 1, WORLD_SIZE_Z], color: wallColor },
{ pos: [0, WORLD_SIZE_Y, 0], size: [WORLD_SIZE_X, 1, WORLD_SIZE_Z], color: ceilingColor }
];

walls.forEach((w, idx) => {
	const geo = new THREE.BoxGeometry(...w.size);
	let mat;
	if (idx < 4) {
		mat = new THREE.MeshStandardMaterial({
			color: wallColor,
			map: concreteTexture,
			roughness: 0.95,
			metalness: 0.0,
			side: THREE.BackSide
		});
	} else {
		mat = new THREE.MeshStandardMaterial({
			color: w.color,
			roughness: 0.9,
			metalness: 0.0,
			side: THREE.BackSide
		});
	}
	const mesh = new THREE.Mesh(geo, mat);
	mesh.position.set(...w.pos);
	scene.add(mesh);
});

const tileSize = 1;
for (let x = 0; x < WORLD_SIZE_X; x++) {
	for (let z = 0; z < WORLD_SIZE_Z; z++) {
		const isDark = (x + z) % 2 === 0;
		const tileColor = isDark ? floorDark : floorLight;
		const tileMat = new THREE.MeshStandardMaterial({
			color: tileColor,
			roughness: 0.95,
			metalness: 0.0
		});
		const tileGeo = new THREE.PlaneGeometry(tileSize, tileSize);
		const tile = new THREE.Mesh(tileGeo, tileMat);
		tile.rotation.x = -Math.PI / 2;
		tile.position.set(
			-WORLD_SIZE_X/2 + x * tileSize + tileSize/2,
			0.01,
			-WORLD_SIZE_Z/2 + z * tileSize + tileSize/2
		);
		scene.add(tile);
	}
}

const bulbGeo = new THREE.SphereGeometry(2, 16, 16);
const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
const bulb = new THREE.Mesh(bulbGeo, bulbMat);
bulb.position.set(0, WORLD_SIZE_Y, 0);
scene.add(bulb);

const cubeSize = 1.5;
const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
const cubeMat = new THREE.MeshStandardMaterial({ color: 0xff9800 });
const interactiveCube = new THREE.Mesh(cubeGeo, cubeMat);
interactiveCube.position.set(0, cubeSize/2, 0);
scene.add(interactiveCube);

const plateSize = 0.25;
const plateGeo = new THREE.PlaneGeometry(plateSize, plateSize);
const plateMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0x333300, side: THREE.DoubleSide });
const switchPlate = new THREE.Mesh(plateGeo, plateMat);
switchPlate.position.set(0, PLAYER_HEIGHT, -WORLD_SIZE_Z/2 + 0.05);
switchPlate.rotation.y = Math.PI;
scene.add(switchPlate);

let heldObject = null;
let lastTapTime = 0;
let doubleTapThreshold = 300;
let isConfirming = false;

function showConfirm(text, onYes, onNo) {
	confirmText.textContent = text;
	confirmYes.onclick = () => {
		onYes();
		confirmBox.style.display = 'none';
		isConfirming = false;
	};
	confirmNo.onclick = () => {
		onNo();
		confirmBox.style.display = 'none';
		isConfirming = false;
	};
	confirmBox.style.display = 'block';
	isConfirming = true;
}

function handleInteraction() {
	if (!isGameActive || isConfirming) return;
	const currentTime = performance.now();
	if (currentTime - lastTapTime < doubleTapThreshold) {
		const direction = new THREE.Vector3();
		camera.getWorldDirection(direction);
		const raycaster = new THREE.Raycaster(camera.position, direction);
		const intersectsCube = raycaster.intersectObject(interactiveCube);
		const intersectsPlate = raycaster.intersectObject(switchPlate);
		const distToPlate = switchPlate.position.distanceTo(camera.position);
		if (intersectsPlate.length > 0 && distToPlate <= 10) {
			showConfirm('Свет: Вкл / Выкл', () => {
				isLampOn = true;
				spotLight.intensity = 9.5;
			}, () => {
				isLampOn = false;
				spotLight.intensity = 0;
			});
		} else if (intersectsCube.length > 0) {
			const distance = intersectsCube[0].distance;
			if (heldObject === null && distance <= 3) {
				showConfirm('Взять?', () => {
					heldObject = interactiveCube;
					cubeUI.style.display = 'block';
					interactiveCube.visible = false;
				}, () => {});
			} else if (heldObject === interactiveCube) {
				showConfirm('Выложить?', () => {
					const offset = new THREE.Vector3(0, 0, -2);
					offset.applyQuaternion(camera.quaternion);
					const dropPos = camera.position.clone().add(offset);
					dropPos.y = cubeSize / 2;
					interactiveCube.position.copy(dropPos);
					interactiveCube.visible = true;
					heldObject = null;
					cubeUI.style.display = 'none';
				}, () => {});
			}
		}
	}
	lastTapTime = currentTime;
}

window.addEventListener('click', handleInteraction);
window.addEventListener('touchend', handleInteraction);

const keys = { w: false, a: false, s: false, d: false };
let joyDir = { x: 0, y: 0 };
let lookX = 0, lookY = 0;
let isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
if (isMobile) {
	document.getElementById('joystick').style.display = 'block';
}

window.addEventListener('keydown', e => {
	if (keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true;
});
window.addEventListener('keyup', e => {
	if (keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false;
});

const joyEl = document.getElementById('joystick');
const stickEl = document.getElementById('stick');
let joyTouchId = null;
let swipeTouchId = null;
let joyStart = { x: 0, y: 0 };
let touchStart = { x: 0, y: 0 };

function getTouchById(touches, id) {
	for (let i = 0; i < touches.length; i++) {
		if (touches[i].identifier === id) return touches[i];
	}
	return null;
}

window.addEventListener('touchstart', e => {
	e.preventDefault();
	const joyRect = joyEl.getBoundingClientRect();
	for (let touch of e.changedTouches) {
		const x = touch.clientX;
		const y = touch.clientY;
		if (x >= joyRect.left && x <= joyRect.right && y >= joyRect.top && y <= joyRect.bottom) {
			if (joyTouchId === null) {
				joyTouchId = touch.identifier;
				joyStart = { x, y };
				joyEl.style.borderColor = 'lime';
			}
		} else {
			if (swipeTouchId === null) {
				swipeTouchId = touch.identifier;
				touchStart = { x, y };
			}
		}
	}
});

window.addEventListener('touchmove', e => {
	e.preventDefault();
	const touches = e.touches;
	if (joyTouchId !== null) {
		const joyTouch = getTouchById(touches, joyTouchId);
		if (joyTouch) {
			const dx = joyTouch.clientX - joyStart.x;
			const dy = joyTouch.clientY - joyStart.y;
			const maxR = 40;
			const dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxR);
			const angle = Math.atan2(dy, dx);
			joyDir.x = Math.cos(angle) * (dist / maxR);
			joyDir.y = Math.sin(angle) * (dist / maxR);
			stickEl.style.transform = `translate(${dx}px, ${dy}px)`;
		}
	}
	if (swipeTouchId !== null) {
		const swipeTouch = getTouchById(touches, swipeTouchId);
		if (swipeTouch) {
			const dx = swipeTouch.clientX - touchStart.x;
			const dy = swipeTouch.clientY - touchStart.y;
			lookX -= dx * 0.005;
			lookY -= dy * 0.005;
			lookY = Math.max(-Math.PI/2, Math.min(Math.PI/2, lookY));
			touchStart.x = swipeTouch.clientX;
			touchStart.y = swipeTouch.clientY;
		}
	}
});

window.addEventListener('touchend', e => {
	for (let touch of e.changedTouches) {
		if (touch.identifier === joyTouchId) {
			joyTouchId = null;
			joyDir.x = 0;
			joyDir.y = 0;
			stickEl.style.transform = 'translate(0,0)';
			joyEl.style.borderColor = 'white';
		}
		if (touch.identifier === swipeTouchId) {
			swipeTouchId = null;
		}
	}
});

window.addEventListener('touchcancel', () => {
	joyTouchId = null;
	swipeTouchId = null;
	joyDir.x = 0;
	joyDir.y = 0;
	stickEl.style.transform = 'translate(0,0)';
	joyEl.style.borderColor = 'white';
});

let mouseDown = false;
renderer.domElement.addEventListener('mousedown', e => {
	if (!isMobile) {
		mouseDown = true;
		renderer.domElement.requestPointerLock();
	}
});
document.addEventListener('mousemove', e => {
	if (mouseDown || document.pointerLockElement === renderer.domElement) {
		lookX -= e.movementX * LOOK_SENSITIVITY;
		lookY -= e.movementY * LOOK_SENSITIVITY;
		lookY = Math.max(-Math.PI/2, Math.min(Math.PI/2, lookY));
	}
});
document.addEventListener('mouseup', () => { mouseDown = false; });

function updatePlayer(delta) {
	let moveForward = 0, moveRight = 0;
	if (!isMobile) {
		if (keys.w) moveForward += 1;
		if (keys.s) moveForward -= 1;
		if (keys.a) moveRight -= 1;
		if (keys.d) moveRight += 1;
	} else {
		moveForward = -joyDir.y;
		moveRight = joyDir.x;
	}
	const len = Math.hypot(moveForward, moveRight);
	if (len > 0) {
		moveForward /= len;
		moveRight /= len;
	}
	const dir = new THREE.Vector3();
	dir.z = -Math.cos(lookX);
	dir.x = -Math.sin(lookX);
	dir.y = 0;
	dir.normalize();
	const right = new THREE.Vector3();
	right.crossVectors(dir, new THREE.Vector3(0, 1, 0)).normalize();
	const speed = MOVE_SPEED * delta;
	camera.position.x += (dir.x * moveForward + right.x * moveRight) * speed;
	camera.position.z += (dir.z * moveForward + right.z * moveRight) * speed;
	camera.position.y = PLAYER_HEIGHT;
	const halfX = WORLD_SIZE_X / 2 - WALL_MARGIN;
	const halfZ = WORLD_SIZE_Z / 2 - WALL_MARGIN;
	camera.position.x = Math.max(-halfX, Math.min(halfX, camera.position.x));
	camera.position.z = Math.max(-halfZ, Math.min(halfZ, camera.position.z));
	camera.rotation.order = 'YXZ';
	camera.rotation.y = lookX;
	camera.rotation.x = lookY;

	if (heldObject) {
		const offset = new THREE.Vector3(0, -0.3, -1.2);
		offset.applyQuaternion(camera.quaternion);
		heldObject.position.copy(camera.position).add(offset);
		heldObject.quaternion.copy(camera.quaternion);
		heldObject.rotateY(Math.PI);
	}

	if (interactiveCube.visible && interactiveCube.position.y !== cubeSize / 2) {
		interactiveCube.position.y = cubeSize / 2;
	}
}

const debugEl = document.getElementById('debug');
let lastTime = 0;
let deltaTime = 16;

function animate(time) {
	if (!isGameActive) return requestAnimationFrame(animate);
	deltaTime = time - lastTime;
	lastTime = time;
	updatePlayer(deltaTime);
	const pos = camera.position;
	const degX = (lookX * 180 / Math.PI).toFixed(1);
	const degY = (lookY * 180 / Math.PI).toFixed(1);
	debugEl.textContent =
`POS: X=${pos.x.toFixed(1)}, Y=${pos.y.toFixed(1)}, Z=${pos.z.toFixed(1)}
` +
`LOOK: Yaw=${degX}°, Pitch=${degY}°
` +
`MOBILE: ${isMobile ? 'Да' : 'Нет'} | FPS: ${Math.round(1000/deltaTime)}`;
	renderer.render(scene, camera);
	requestAnimationFrame(animate);
}

window.addEventListener('resize', () => {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
});

animate(0);
gameInitialized = true;
}

document.getElementById('playBtn').onclick = () => {
	mainMenu.style.display = 'none';
	pauseBtn.style.display = 'block';
	isGameActive = true;
	initGame();
};
document.getElementById('exitBtn').onclick = () => {
	if (confirm('Выйти из игры?')) {}
};
pauseBtn.onclick = () => {
	isGameActive = false;
	pauseMenu.style.display = 'flex';
};
document.getElementById('resumeBtn').onclick = () => {
	pauseMenu.style.display = 'none';
	isGameActive = true;
};
document.getElementById('backToMenuBtn').onclick = () => {
	pauseMenu.style.display = 'none';
	mainMenu.style.display = 'block';
	pauseBtn.style.display = 'none';
	isGameActive = false;
	const canvas = document.querySelector('canvas');
	if (canvas) canvas.remove();
	gameInitialized = false;
	document.getElementById('joystick').style.display = 'none';
	cubeUI.style.display = 'none';
};
</script>
</body>
</html>
