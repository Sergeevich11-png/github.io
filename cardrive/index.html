<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Гонки — 1 Круг</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    body {
      overflow: hidden;
      background: #0d0d0d;
      touch-action: none;
      color: white;
    }
    #main-menu {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      z-index: 10;
    }
    #main-menu.hidden { display: none; }
    #main-menu h1 {
      font-size: 32px;
      margin-bottom: 40px;
      text-align: center;
      color: #4cc9f0;
    }
    .btn {
      width: 220px;
      height: 60px;
      margin: 12px 0;
      font-size: 20px;
      font-weight: bold;
      background: #4361ee;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn:hover, .btn:active { background: #3a56d4; }
    #game-canvas {
      display: block;
    }
    #pause-btn {
      position: absolute;
      top: 15px;
      left: 15px;
      width: 44px;
      height: 44px;
      background: rgba(0, 0, 0, 0.6);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 24px;
      cursor: pointer;
      z-index: 10;
    }
    #controls {
      position: absolute;
      bottom: 25px;
      width: 100%;
      display: flex;
      justify-content: space-around;
      padding: 0 20px;
      z-index: 10;
    }
    .ctrl-btn {
      width: 85px;
      height: 85px;
      background: rgba(0, 180, 255, 0.85);
      border: none;
      border-radius: 50%;
      color: white;
      font-weight: bold;
      font-size: 18px;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.92);
      color: #ffeb3b;
      padding: 20px 35px;
      border-radius: 16px;
      font-size: 28px;
      font-weight: bold;
      opacity: 0;
      pointer-events: none;
      z-index: 20;
      text-align: center;
      transition: opacity 0.3s;
      border: 2px solid #ffeb3b;
    }
    #mini-map {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 120px;
      height: 120px;
      z-index: 9;
      pointer-events: none;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
    }
  </style>
</head>
<body>

<div id="main-menu">
  <h1>ГОНКИ: 1 КРУГ</h1>
  <button id="btn-start" class="btn">Начать гонку</button>
  <button id="btn-exit" class="btn">К списку игр</button>
</div>

<canvas id="game-canvas"></canvas>
<canvas id="mini-map"></canvas>
<button id="pause-btn">⏸</button>
<div id="controls">
  <button id="btn-brake" class="ctrl-btn">Тормоз</button>
  <button id="btn-gas" class="ctrl-btn">Газ</button>
</div>
<div id="message">ФИНИШ!</div>

<script type="module">
// ✅ ИСПРАВЛЕНО: удалены все пробелы в конце URL
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';

// ✅ ИСПРАВЛЕНО: правильный путь (без /github.io/)
const GAMES_INDEX_URL = 'https://sergeevich11-png.github.io/';

let state = 'main-menu';
let renderer, scene, camera, carMesh;

let x = 0, z = 0, angle = 0;
let speed = 0;

let initialGamma = null;
let rawWheelInput = 0;
let wheelInput = 0;

let frontWheelL, frontWheelR;

let isGas = false, isBrake = false;
let passedMid = false;
let finished = false;

const trackRadius = 65;
const trackWidth = 12;
const R_in = trackRadius - trackWidth / 2;
const R_out = trackRadius + trackWidth / 2;

const mainMenu = document.getElementById('main-menu');
const pauseBtn = document.getElementById('pause-btn');
const gasBtn = document.getElementById('btn-gas');
const brakeBtn = document.getElementById('btn-brake');
const messageEl = document.getElementById('message');
const canvas = document.getElementById('game-canvas');
const miniMapCanvas = document.getElementById('mini-map');
const miniMapCtx = miniMapCanvas.getContext('2d');

// КНОПКИ
document.getElementById('btn-start').addEventListener('click', () => {
  mainMenu.classList.add('hidden');
  startGame();
});

document.getElementById('btn-exit').addEventListener('click', () => {
  window.location.href = GAMES_INDEX_URL;
});

pauseBtn.addEventListener('click', () => {
  if (state === 'playing') {
    state = 'paused';
    mainMenu.classList.remove('hidden');
    canvas.style.display = 'none';
    pauseBtn.style.display = 'none';
    document.getElementById('controls').style.display = 'none';
  }
});

const bindButton = (el, down, up) => {
  const downHandler = (e) => { e.preventDefault(); down(); };
  el.addEventListener('touchstart', downHandler, { passive: false });
  el.addEventListener('mousedown', downHandler);
  const end = () => up();
  el.addEventListener('touchend', end);
  el.addEventListener('mouseup', end);
  el.addEventListener('mouseleave', end);
};
bindButton(gasBtn, () => isGas = true, () => isGas = false);
bindButton(brakeBtn, () => isBrake = true, () => isBrake = false);

// СОЗДАНИЕ МАШИНЫ
function createCar() {
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(1.3, 0.55, 2.2),
    new THREE.MeshPhongMaterial({ color: 0xff3333 })
  );
  const nose = new THREE.Mesh(
    new THREE.BoxGeometry(0.4, 0.3, 0.3),
    new THREE.MeshPhongMaterial({ color: 0xffff00 })
  );
  nose.position.set(0, 0.2, -1.2);
  body.add(nose);

  const wheelGeom = new THREE.CylinderGeometry(0.35, 0.35, 0.4, 12);
  wheelGeom.rotateZ(Math.PI / 2);
  const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });

  frontWheelL = new THREE.Mesh(wheelGeom, wheelMat);
  frontWheelL.position.set(-0.7, -0.3, -0.9);
  body.add(frontWheelL);

  frontWheelR = new THREE.Mesh(wheelGeom, wheelMat);
  frontWheelR.position.set(0.7, -0.3, -0.9);
  body.add(frontWheelR);

  const rearL = new THREE.Mesh(wheelGeom, wheelMat);
  rearL.position.set(-0.7, -0.3, 0.9);
  body.add(rearL);

  const rearR = new THREE.Mesh(wheelGeom, wheelMat);
  rearR.position.set(0.7, -0.3, 0.9);
  body.add(rearR);

  return body;
}

// ГИРОСКОП
const handleOrientation = (e) => {
  if (state !== 'playing' || e.gamma === null) return;
  if (initialGamma === null) initialGamma = e.gamma;
  const deltaGamma = e.gamma - initialGamma;
  const clamped = Math.max(-25, Math.min(25, deltaGamma));
  const deadZone = 3;
  let input = 0;
  if (Math.abs(clamped) > deadZone) {
    input = (Math.abs(clamped) - deadZone) / (25 - deadZone);
    input *= Math.sign(clamped);
  }
  rawWheelInput = input;
  wheelInput = wheelInput * 0.7 + rawWheelInput * 0.3;
};

// ЗАПУСК
function tryLockLandscape() {
  if (screen.orientation?.lock) {
    screen.orientation.lock('landscape').catch(() => {});
  }
}

function startGame() {
  if (state === 'playing') return;
  state = 'playing';
  tryLockLandscape();

  initialGamma = null;
  wheelInput = 0;
  rawWheelInput = 0;

  canvas.style.display = 'block';
  pauseBtn.style.display = 'block';
  document.getElementById('controls').style.display = 'flex';

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x225522);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

  renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  updateRendererSize();

  const road = new THREE.Mesh(new THREE.RingGeometry(R_in, R_out, 128), new THREE.MeshStandardMaterial({ color: 0x444444 }));
  road.rotation.x = Math.PI / 2;
  scene.add(road);

  const lineInner = new THREE.Mesh(new THREE.RingGeometry(R_in + 0.5, R_in + 0.6, 128), new THREE.MeshBasicMaterial({ color: 0xffffff }));
  lineInner.rotation.x = Math.PI / 2;
  scene.add(lineInner);
  const lineOuter = new THREE.Mesh(new THREE.RingGeometry(R_out - 0.6, R_out - 0.5, 128), new THREE.MeshBasicMaterial({ color: 0xffffff }));
  lineOuter.rotation.x = Math.PI / 2;
  scene.add(lineOuter);

  const startLine = new THREE.Mesh(
    new THREE.PlaneGeometry(trackWidth, 1.5),
    new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide })
  );
  startLine.rotation.x = Math.PI / 2;
  startLine.position.set(trackRadius, 0.1, 0);
  scene.add(startLine);

  const createBarrier = (radius, color) => {
    const points = [];
    for (let i = 0; i <= 128; i++) {
      const a = (i / 128) * Math.PI * 2;
      points.push(new THREE.Vector3(Math.cos(a) * radius, 0.3, Math.sin(a) * radius));
    }
    const curve = new THREE.CatmullRomCurve3(points);
    curve.closed = true;
    const tube = new THREE.TubeGeometry(curve, 128, 0.4, 8, true);
    scene.add(new THREE.Mesh(tube, new THREE.MeshPhongMaterial({ color })));
  };
  createBarrier(R_in - 0.6, 0x0066ff);
  createBarrier(R_out + 0.6, 0xff0000);

  carMesh = createCar();
  scene.add(carMesh);

  scene.add(new THREE.AmbientLight(0x888888));
  const sun = new THREE.DirectionalLight(0xffffff, 1.2);
  sun.position.set(20, 50, 20);
  scene.add(sun);

  if (typeof DeviceOrientationEvent !== 'undefined' && DeviceOrientationEvent.requestPermission) {
    DeviceOrientationEvent.requestPermission().then(permission => {
      if (permission === 'granted') {
        window.addEventListener('deviceorientation', handleOrientation, { passive: true });
      }
    }).catch(console.warn);
  } else {
    window.addEventListener('deviceorientation', handleOrientation, { passive: true });
  }

  x = trackRadius - 3;
  z = 0;
  angle = Math.PI / 2;
  speed = 0;
  passedMid = false;
  finished = false;

  miniMapCanvas.width = 120;
  miniMapCanvas.height = 120;

  animate();
}

function updateRendererSize() {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', () => { if (state === 'playing') updateRendererSize(); });

// КОЛЛИЗИЯ
function constrain(posX, posZ) {
  const d = Math.sqrt(posX * posX + posZ * posZ);
  if (d < R_in) {
    const f = (R_in + 0.3) / d;
    posX *= f; posZ *= f;
    speed *= 0.8;
  } else if (d > R_out) {
    const f = (R_out - 0.3) / d;
    posX *= f; posZ *= f;
    speed *= 0.8;
  }
  return { x: posX, z: posZ };
}

// ИГРОВОЙ ЦИКЛ
function animate() {
  if (state !== 'playing') return;

  const dt = 0.016;

  if (isGas) speed += 1.0 * dt * 60;
  if (isBrake) speed -= 1.3 * dt * 60;
  if (!isGas && !isBrake) speed *= Math.pow(0.91, dt * 60);
  speed = Math.max(-2.0, Math.min(speed, 5.5));

  angle += wheelInput * 0.022;

  x += Math.cos(angle) * speed * dt * 20;
  z += Math.sin(angle) * speed * dt * 20;

  const clamped = constrain(x, z);
  x = clamped.x;
  z = clamped.z;

  carMesh.position.set(x, 0.6, z);
  carMesh.rotation.y = angle + Math.PI / 2;

  if (frontWheelL && frontWheelR) {
    const visualTurn = wheelInput * 0.7;
    frontWheelL.rotation.z = Math.PI / 2 + visualTurn;
    frontWheelR.rotation.z = Math.PI / 2 + visualTurn;
  }

  camera.position.set(x, 7, z - 16);
  camera.lookAt(x, 1, z);

  const curAngle = Math.atan2(z, x);
  let normA = curAngle;
  if (normA < 0) normA += Math.PI * 2;

  if (!passedMid && normA > Math.PI - 0.5 && normA < Math.PI + 0.5) {
    passedMid = true;
  }

  const inFinishZone = normA < 0.3 || normA > Math.PI * 2 - 0.3;
  const nearStartPoint = Math.abs(x - trackRadius) < 5 && Math.abs(z) < 2;

  if (passedMid && inFinishZone && nearStartPoint && !finished) {
    finished = true;
    showMessage("КРУГ ЗАВЕРШЕН!");
  }

  miniMapCtx.clearRect(0, 0, 120, 120);
  const cx = 60, cy = 60, s = 0.8;
  miniMapCtx.strokeStyle = '#555';
  miniMapCtx.lineWidth = trackWidth * s;
  miniMapCtx.beginPath();
  miniMapCtx.arc(cx, cy, trackRadius * s, 0, Math.PI * 2);
  miniMapCtx.stroke();
  miniMapCtx.strokeStyle = '#ff0000';
  miniMapCtx.lineWidth = 3;
  miniMapCtx.beginPath();
  miniMapCtx.arc(cx, cy, trackRadius * s, -0.1, 0.1);
  miniMapCtx.stroke();
  miniMapCtx.fillStyle = '#ff3333';
  miniMapCtx.fillRect(cx + x * s - 2, cy + z * s - 2, 4, 4);

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

function showMessage(text) {
  messageEl.textContent = text;
  messageEl.style.opacity = '1';
  state = 'finished';
  setTimeout(() => {
    messageEl.style.opacity = '0';
    mainMenu.classList.remove('hidden');
    canvas.style.display = 'none';
    pauseBtn.style.display = 'none';
    document.getElementById('controls').style.display = 'none';
  }, 3000);
}
</script>
</body>
</html>
