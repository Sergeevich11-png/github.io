<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>–ì–æ–Ω–∫–∏ ‚Äî 1 –ö—Ä—É–≥</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
    body {
      overflow: hidden;
      background: #0d0d0d;
      touch-action: none;
      color: white;
    }
    #main-menu {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      z-index: 10;
    }
    #main-menu.hidden { display: none; }
    #main-menu h1 {
      font-size: 32px;
      margin-bottom: 40px;
      text-align: center;
      color: #4cc9f0;
    }
    .btn {
      width: 220px;
      height: 60px;
      margin: 12px 0;
      font-size: 20px;
      font-weight: bold;
      background: #4361ee;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn:hover, .btn:active { background: #3a56d4; }
    #game-canvas {
      display: block;
    }
    #pause-btn {
      position: absolute;
      top: 15px;
      left: 15px;
      width: 44px;
      height: 44px;
      background: rgba(0, 0, 0, 0.6);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 24px;
      cursor: pointer;
      z-index: 10;
    }
    #controls {
      position: absolute;
      bottom: 25px;
      width: 100%;
      display: flex;
      justify-content: space-around;
      padding: 0 20px;
      z-index: 10;
    }
    .ctrl-btn {
      width: 85px;
      height: 85px;
      background: rgba(0, 180, 255, 0.85);
      border: none;
      border-radius: 50%;
      color: white;
      font-weight: bold;
      font-size: 18px;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 20px 35px;
      border-radius: 16px;
      font-size: 28px;
      font-weight: bold;
      opacity: 0;
      pointer-events: none;
      z-index: 20;
      text-align: center;
      transition: opacity 0.3s;
    }
    #orientation-blocker {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: #0d0d1a;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      color: #f8f9fa;
    }
    #orientation-blocker.active { display: flex; }
    #orientation-blocker p {
      font-size: 22px;
      text-align: center;
      max-width: 80%;
      margin-bottom: 30px;
      line-height: 1.4;
    }
    #orientation-icon {
      font-size: 60px;
      margin-bottom: 20px;
    }
    #mini-map {
      position: absolute;
      top: 15px;
      left: 15px;
      width: 120px;
      height: 120px;
      z-index: 9;
      pointer-events: none;
    }
  </style>
</head>
<body>

<div id="main-menu">
  <h1>–ì–û–ù–ö–ò: 1 –ö–†–£–ì</h1>
  <button id="btn-start" class="btn">1 –∫—Ä—É–≥</button>
  <button id="btn-exit" class="btn">–í—ã—Ö–æ–¥</button>
</div>

<div id="orientation-blocker">
  <div id="orientation-icon">‚ÜîÔ∏è</div>
  <p>–ü–æ–≤–µ—Ä–Ω–∏—Ç–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –≤ –∞–ª—å–±–æ–º–Ω—É—é –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é –¥–ª—è –Ω–∞—á–∞–ª–∞ –≥–æ–Ω–∫–∏</p>
</div>

<canvas id="game-canvas"></canvas>
<canvas id="mini-map"></canvas>
<button id="pause-btn">‚â°</button>
<div id="controls">
  <button id="btn-brake" class="ctrl-btn">–¢–æ—Ä–º–æ–∑</button>
  <button id="btn-gas" class="ctrl-btn">–ì–∞–∑</button>
</div>
<div id="message">–§–ò–ù–ò–®!</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';

let state = 'main-menu';
let renderer, scene, camera;
let playerCarMesh;

let car = {
  rear: new THREE.Vector3(),
  front: new THREE.Vector3(),
  angle: 0,
  speed: 0,
  steeringAngle: 0
};

let isGas = false, isBrake = false;
let playerPassedMidpoint = false;
let playerFinished = false;

const trackRadius = 65;
const trackWidth = 12;
const R_in = trackRadius - trackWidth / 2;
const R_out = trackRadius + trackWidth / 2;

const mainMenu = document.getElementById('main-menu');
const blocker = document.getElementById('orientation-blocker');
const pauseBtn = document.getElementById('pause-btn');
const gasBtn = document.getElementById('btn-gas');
const brakeBtn = document.getElementById('btn-brake');
const messageEl = document.getElementById('message');
const canvas = document.getElementById('game-canvas');
const miniMapCanvas = document.getElementById('mini-map');
const miniMapCtx = miniMapCanvas.getContext('2d');

document.getElementById('btn-start').addEventListener('click', () => {
  mainMenu.classList.add('hidden');
  blocker.classList.add('active');
  checkOrientation();
});

document.getElementById('btn-exit').addEventListener('click', () => {
  window.location.href = 'https://sergeevich11-png.github.io/github.io/';
});

pauseBtn.addEventListener('click', () => {
  if (state === 'playing') {
    state = 'paused';
    mainMenu.classList.remove('hidden');
    canvas.style.display = 'none';
    pauseBtn.style.display = 'none';
    document.getElementById('controls').style.display = 'none';
  }
});

const bindButton = (el, down, up) => {
  el.addEventListener('touchstart', down);
  el.addEventListener('mousedown', down);
  const end = () => { up(); };
  el.addEventListener('touchend', end);
  el.addEventListener('mouseup', end);
  el.addEventListener('mouseleave', end);
};
bindButton(gasBtn, () => isGas = true, () => isGas = false);
bindButton(brakeBtn, () => isBrake = true, () => isBrake = false);

function checkOrientation() {
  const isLandscape = window.innerWidth > window.innerHeight;
  if (isLandscape && state !== 'playing') {
    blocker.classList.remove('active');
    startGame();
  } else {
    setTimeout(checkOrientation, 300);
  }
}

window.addEventListener('resize', () => {
  if (state === 'playing') {
    updateRendererSize();
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    miniMapCanvas.width = 120;
    miniMapCanvas.height = 120;
  } else {
    checkOrientation();
  }
});

function constrainToTrack(pos) {
  const dx = pos.x, dz = pos.z;
  const dist = Math.sqrt(dx * dx + dz * dz);
  let pushed = false;
  if (dist < R_in) {
    const push = (R_in - dist + 0.25);
    const nx = -dx / dist, nz = -dz / dist;
    pos.x += nx * push;
    pos.z += nz * push;
    pushed = true;
  } else if (dist > R_out) {
    const push = (dist - R_out + 0.25);
    const nx = dx / dist, nz = dz / dist;
    pos.x -= nx * push;
    pos.z -= nz * push;
    pushed = true;
  }
  return pushed;
}

function startGame() {
  if (state === 'playing') return;
  state = 'playing';

  canvas.style.display = 'block';
  pauseBtn.style.display = 'block';
  document.getElementById('controls').style.display = 'flex';

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x336633);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

  renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  updateRendererSize();

  // –î–æ—Ä–æ–≥–∞
  const roadGeo = new THREE.RingGeometry(R_in, R_out, 128);
  const roadMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.9 });
  const road = new THREE.Mesh(roadGeo, roadMat);
  road.rotation.x = Math.PI / 2;
  scene.add(road);

  // –†–∞–∑–º–µ—Ç–∫–∞
  const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const lineInner = new THREE.Mesh(new THREE.RingGeometry(R_in + 0.5, R_in + 0.6, 128), lineMat);
  lineInner.rotation.x = Math.PI / 2;
  scene.add(lineInner);
  const lineOuter = new THREE.Mesh(new THREE.RingGeometry(R_out - 0.6, R_out - 0.5, 128), lineMat);
  lineOuter.rotation.x = Math.PI / 2;
  scene.add(lineOuter);

  // –°—Ç–∞—Ä—Ç
  const startLine = new THREE.Mesh(
    new THREE.PlaneGeometry(trackWidth, 1.5),
    new THREE.MeshBasicMaterial({ color: 0xff0000 })
  );
  startLine.rotation.x = Math.PI / 2;
  startLine.position.set(trackRadius, 0, 0);
  scene.add(startLine);

  // –ë–æ—Ä–¥—é—Ä—ã
  const createBarrier = (radius) => {
    const points = [];
    for (let i = 0; i <= 128; i++) {
      const a = (i / 128) * Math.PI * 2;
      points.push(new THREE.Vector3(Math.cos(a) * radius, 0.3, Math.sin(a) * radius));
    }
    const curve = new THREE.CatmullRomCurve3(points);
    curve.closed = true;
    const tube = new THREE.TubeGeometry(curve, 128, 0.4, 8, true);
    const mat = new THREE.MeshPhongMaterial({ color: 0x0066ff });
    const mesh = new THREE.Mesh(tube, mat);
    scene.add(mesh);
  };
  createBarrier(R_in - 0.6);
  createBarrier(R_out + 0.6);

  // –ú–∞—à–∏–Ω–∞ –∏–≥—Ä–æ–∫–∞
  playerCarMesh = createCar(0xff3333, 0xffff00);
  scene.add(playerCarMesh);

  // –û—Å–≤–µ—â–µ–Ω–∏–µ
  scene.add(new THREE.AmbientLight(0x888888));
  const sun = new THREE.DirectionalLight(0xffffff, 1.2);
  sun.position.set(20, 50, 20);
  scene.add(sun);

  // –ì–∏—Ä–æ—Å–∫–æ–ø
  if (typeof DeviceOrientationEvent !== 'undefined') {
    window.addEventListener('deviceorientation', handleOrientation, { passive: true });
    if (DeviceOrientationEvent.requestPermission) {
      DeviceOrientationEvent.requestPermission().catch(console.warn);
    }
  }

  // –°–±—Ä–æ—Å
  car.rear.set(trackRadius - 3, 0, -1.1);
  car.front.set(trackRadius - 3, 0, 1.1);
  car.angle = Math.PI / 2;
  car.speed = 0;
  car.steeringAngle = 0;
  isGas = false; isBrake = false;
  playerPassedMidpoint = false;
  playerFinished = false;

  miniMapCanvas.width = 120;
  miniMapCanvas.height = 120;

  animate();
}

function updateRendererSize() {
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function handleOrientation(e) {
  if (state !== 'playing') return;
  if (e.gamma !== null) {
    car.steeringAngle = -(e.gamma / 90) * 0.55;
  }
}

function createCar(color, noseColor) {
  const group = new THREE.Group();
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(1.3, 0.55, 2.2),
    new THREE.MeshPhongMaterial({ color })
  );
  group.add(body);
  const nose = new THREE.Mesh(
    new THREE.BoxGeometry(0.4, 0.3, 0.3),
    new THREE.MeshPhongMaterial({ color: noseColor })
  );
  nose.position.set(0, 0.2, -1.2);
  group.add(nose);
  const wheelGeo = new THREE.CylinderGeometry(0.32, 0.32, 0.22, 16);
  wheelGeo.rotateZ(Math.PI / 2);
  const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
  const addWheel = (x, z) => {
    const w = new THREE.Mesh(wheelGeo, wheelMat);
    w.position.set(x, -0.32, z);
    group.add(w);
  };
  addWheel(0.75, 0.9);
  addWheel(-0.75, 0.9);
  addWheel(0.75, -0.9);
  addWheel(-0.75, -0.9);
  return group;
}

function updateCamera() {
  const bodyX = (car.rear.x + car.front.x) * 0.5;
  const bodyZ = (car.rear.z + car.front.z) * 0.5;
  const offset = new THREE.Vector3(0, 6, -12);
  offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), car.angle);
  camera.position.set(bodyX, 0, bodyZ).add(offset);
  camera.lookAt(bodyX, 1, bodyZ);
}

function drawMiniMap() {
  const size = 120;
  const scale = 0.8;
  miniMapCtx.clearRect(0, 0, size, size);
  const cx = size / 2, cy = size / 2;
  const r = trackRadius * scale;
  miniMapCtx.strokeStyle = '#555';
  miniMapCtx.lineWidth = trackWidth * scale;
  miniMapCtx.beginPath();
  miniMapCtx.arc(cx, cy, r, 0, Math.PI * 2);
  miniMapCtx.stroke();
  miniMapCtx.fillStyle = '#ff0000';
  miniMapCtx.fillRect(cx + r - 2, cy - 1, 4, 2);
  const px = cx + ((car.rear.x + car.front.x) * 0.5) * scale;
  const pz = cy + ((car.rear.z + car.front.z) * 0.5) * scale;
  miniMapCtx.fillStyle = '#ff3333';
  miniMapCtx.fillRect(px - 2, pz - 2, 4, 4);
}

function showMessage(text) {
  messageEl.textContent = text;
  messageEl.style.opacity = '1';
  state = 'finished';
  setTimeout(() => messageEl.style.opacity = '0', 3000);
  setTimeout(() => {
    mainMenu.classList.remove('hidden');
    canvas.style.display = 'none';
    pauseBtn.style.display = 'none';
    document.getElementById('controls').style.display = 'none';
  }, 3000);
}

const clock = new THREE.Clock();

function animate() {
  if (state !== 'playing') return;

  const delta = Math.min(clock.getDelta(), 0.033);

  // –£—Å–∫–æ—Ä–µ–Ω–∏–µ
  if (isGas) car.speed += 25 * delta;
  if (isBrake) car.speed -= 30 * delta;
  if (!isGas && !isBrake) car.speed *= 0.93;
  car.speed = Math.max(-20, Math.min(car.speed, 40));

  // üî• –ö–õ–Æ–ß–ï–í–û–ô –§–ò–ö–°: –ø–æ–≤–æ—Ä–æ—Ç —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏
  let effectiveSteering = 0;
  if (Math.abs(car.speed) > 0.5) {
    effectiveSteering = car.steeringAngle;
  }

  // –î–≤–∏–∂–µ–Ω–∏–µ –∑–∞–¥–Ω–µ–π –æ—Å–∏
  const rearDirX = Math.cos(car.angle);
  const rearDirZ = Math.sin(car.angle);
  car.rear.x += rearDirX * car.speed * delta;
  car.rear.z += rearDirZ * car.speed * delta;

  // –ü–µ—Ä–µ–¥–Ω—è—è –æ—Å—å ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ–¥–µ–º
  const frontDirX = Math.cos(car.angle + effectiveSteering);
  const frontDirZ = Math.sin(car.angle + effectiveSteering);
  car.front.x = car.rear.x + frontDirX * 2.2;
  car.front.z = car.rear.z + frontDirZ * 2.2;

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É–≥–ª–∞ –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –º–∞—à–∏–Ω–∞ –¥–≤–∏–∂–µ—Ç—Å—è
  if (Math.abs(car.speed) > 0.5) {
    car.angle = Math.atan2(car.front.z - car.rear.z, car.front.x - car.rear.x);
  }

  // –ö–æ–ª–ª–∏–∑–∏–∏
  let pushed = false;
  pushed |= constrainToTrack(car.rear);
  pushed |= constrainToTrack(car.front);
  if (pushed) car.speed *= 0.85;

  // –ü–æ–∑–∏—Ü–∏—è –≤–∏–∑—É–∞–ª–∞
  const bodyX = (car.rear.x + car.front.x) * 0.5;
  const bodyZ = (car.rear.z + car.front.z) * 0.5;
  playerCarMesh.position.set(bodyX, 0.6, bodyZ);
  playerCarMesh.rotation.y = car.angle + Math.PI / 2;

  // –§–∏–Ω–∏—à
  const playerAngle = Math.atan2(bodyZ, bodyX);
  const normAngle = ((playerAngle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
  if (!playerPassedMidpoint && normAngle > Math.PI - 0.3 && normAngle < Math.PI + 0.3) {
    playerPassedMidpoint = true;
  }
  const inFinishZone = normAngle < 0.2 || normAngle > Math.PI * 2 - 0.2;
  const nearStart = Math.abs(bodyX - trackRadius) < 5 && Math.abs(bodyZ) < 2;
  if (playerPassedMidpoint && inFinishZone && nearStart && !playerFinished) {
    playerFinished = true;
    showMessage("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!");
  }

  updateCamera();
  renderer.render(scene, camera);
  drawMiniMap();

  requestAnimationFrame(animate);
}
</script>
</body>
</html>
