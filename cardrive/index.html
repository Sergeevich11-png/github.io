<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Тест машинки (гироскоп)</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      touch-action: none;
      background: #000;
    }
    canvas { display: block; }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 0 10px;
      box-sizing: border-box;
    }
    .ctrl-btn {
      background: rgba(0, 180, 255, 0.85);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 28px;
      font-weight: bold;
      width: 80px;
      height: 80px;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 4px 12px rgba(0, 100, 200, 0.5);
    }

    #speedometer {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 10px 16px;
      border-radius: 8px;
      font-family: monospace;
      font-size: 24px;
      font-weight: bold;
      z-index: 10;
    }
  </style>
</head>
<body>

<div id="controls">
  <button id="btn-up" class="ctrl-btn">▲</button>
  <button id="btn-down" class="ctrl-btn">▼</button>
</div>

<div id="speedometer">00 км/ч</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

const asphalt = new THREE.Mesh(
  new THREE.PlaneGeometry(100, 100),
  new THREE.MeshStandardMaterial({ color: 0x333333 })
);
asphalt.rotation.x = -Math.PI / 2;
scene.add(asphalt);

scene.add(new THREE.AmbientLight(0x666666));
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(10, 20, 10);
scene.add(sun);

const car = new THREE.Group();
const body = new THREE.Mesh(
  new THREE.BoxGeometry(2, 0.8, 4),
  new THREE.MeshPhongMaterial({ color: 0xff3333 })
);
car.add(body);

// === ПРАВИЛЬНЫЕ КОЛЁСА: стоят вертикально ===
const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);
// Cylinder по умолчанию "лежит", поэтому поворачиваем его на 90° вокруг X
wheelGeo.rotateX(Math.PI / 2);
const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });

const createWheel = (x, z) => {
  const w = new THREE.Mesh(wheelGeo, wheelMat);
  w.position.set(x, -0.6, z);
  return w;
};

const wheelFL = createWheel(-1.1, -1.5);
const wheelFR = createWheel(1.1, -1.5);
const wheelRL = createWheel(-1.1, 1.5);
const wheelRR = createWheel(1.1, 1.5);

car.add(wheelFL, wheelFR, wheelRL, wheelRR);
scene.add(car);

const poleMat = new THREE.MeshStandardMaterial();
const poleGeo = new THREE.CylinderGeometry(0.3, 0.3, 3, 8);

const addPole = (x, z, color) => {
  const pole = new THREE.Mesh(poleGeo, poleMat.clone());
  pole.material.color.set(color);
  pole.position.set(x, 1.5, z);
  scene.add(pole);
};

for (let x = -50; x <= 50; x += 10) addPole(x, -50, 0x00ff00);
for (let x = -50; x <= 50; x += 10) addPole(x, 50, 0x8B4513);
for (let z = -50; z <= 50; z += 10) addPole(-50, z, 0x9400d3);
for (let z = -50; z <= 50; z += 10) addPole(50, z, 0xff69b4);

const state = { forward: false, backward: false };
const speedometerEl = document.getElementById('speedometer');

const bindTouch = (el, key) => {
  const start = () => { state[key] = true; };
  const end = () => { state[key] = false; };
  el.addEventListener('touchstart', (e) => { e.preventDefault(); start(); }, { passive: false });
  el.addEventListener('mousedown', start);
  el.addEventListener('touchend', end);
  el.addEventListener('mouseup', end);
  el.addEventListener('mouseleave', end);
};

bindTouch(document.getElementById('btn-up'), 'forward');
bindTouch(document.getElementById('btn-down'), 'backward');

// === ГИРОСКОП ===
let initialGamma = null;
let gamma = 0;

const handleOrientation = (e) => {
  if (e.gamma === null) return;
  gamma = e.gamma;
  if (initialGamma === null) {
    initialGamma = e.gamma;
  }
};

if (typeof DeviceOrientationEvent !== 'undefined' && DeviceOrientationEvent.requestPermission) {
  DeviceOrientationEvent.requestPermission().then(permission => {
    if (permission === 'granted') {
      window.addEventListener('deviceorientation', handleOrientation, { passive: true });
    }
  }).catch(console.warn);
} else {
  window.addEventListener('deviceorientation', handleOrientation, { passive: true });
}

// === ФИЗИКА ===
const maxSteerAngle = Math.PI / 4; // 45°
let currentSpeed = 0;
const maxSpeed = 9;
const clock = new THREE.Clock();

function update() {
  const delta = Math.min(clock.getDelta(), 0.05);

  // === ПОВОРОТ: мёртвая зона 0.35° + пропорциональность ===
  let steerAngle = 0;
  if (initialGamma !== null) {
    const deltaGamma = gamma - initialGamma;
    const deadZone = 0.35;
    let effectiveDelta = 0;
    if (Math.abs(deltaGamma) > deadZone) {
      effectiveDelta = Math.sign(deltaGamma) * (Math.abs(deltaGamma) - deadZone);
    }
    const normalized = Math.min(1, Math.max(-1, effectiveDelta / (25 - deadZone)));
    const steerInput = normalized * Math.abs(normalized); // x²·sign(x)
    steerAngle = steerInput * maxSteerAngle;
  }

  // === ВИЗУАЛЬНЫЙ ПОВОРОТ КОЛЁС (вокруг Y) ===
  wheelFL.rotation.y = steerAngle;
  wheelFR.rotation.y = steerAngle;
  // Задние колёса не поворачиваются
  wheelRL.rotation.y = 0;
  wheelRR.rotation.y = 0;

  // === СКОРОСТЬ: 3.5 сек до максимума, 6 сек до остановки ===
  if (state.forward) {
    currentSpeed += 0.75 * delta * 60; // ~3.5 сек до maxSpeed=9
  } else if (state.backward) {
    currentSpeed -= 0.5 * delta * 60;
  } else {
    // Плавное торможение: 6 сек от 9 до 0
    currentSpeed *= Math.pow(0.935, delta * 60);
  }
  currentSpeed = Math.max(-maxSpeed / 2, Math.min(maxSpeed, currentSpeed));

  // === Ограничение в повороте ===
  const steerAbs = Math.abs(steerAngle / maxSteerAngle);
  const effectiveMaxSpeed = maxSpeed * (1 - 0.5 * steerAbs);
  if (currentSpeed > effectiveMaxSpeed) {
    currentSpeed = effectiveMaxSpeed;
  }

  // === ПОВОРОТ КУЗОВА ===
  if (Math.abs(currentSpeed) > 0.05 && Math.abs(steerAngle) > 0.01) {
    const turnRate = (Math.abs(currentSpeed) / maxSpeed) * 1.6;
    car.rotation.y -= steerAngle * turnRate * delta;
  }

  // === ПОЗИЦИЯ ===
  car.position.y = 0.6;
  const direction = new THREE.Vector3(0, 0, -1).applyEuler(car.rotation);
  car.position.x += direction.x * currentSpeed * delta;
  car.position.z += direction.z * currentSpeed * delta;

  // === КАМЕРА ===
  const forward = new THREE.Vector3(0, 0, -1).applyEuler(car.rotation).normalize();
  camera.position.copy(car.position).add(forward.clone().multiplyScalar(-16));
  camera.position.y += 8;
  const lookAtPoint = car.position.clone().add(forward.clone().multiplyScalar(5));
  lookAtPoint.y += 1.5;
  camera.lookAt(lookAtPoint);

  // === СПИДОМЕТР ===
  const speedKmh = Math.abs(currentSpeed * 10); // условные км/ч
  let display = '';
  if (currentSpeed < -0.1) {
    display = `R ${speedKmh.toFixed(0).padStart(2, '0')} км/ч`;
  } else {
    display = `${speedKmh.toFixed(0).padStart(2, '0')} км/ч`;
  }
  speedometerEl.textContent = display;
}

function animate() {
  requestAnimationFrame(animate);
  update();
  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

car.position.set(0, 0.6, 0);
scene.add(car);

animate();
</script>
</body>
</html>
