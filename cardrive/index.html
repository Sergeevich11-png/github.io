<script>
  let state = 'main-menu'; // main-menu | playing | finished

  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  const miniMapCanvas = document.getElementById('mini-map');
  const miniMapCtx = miniMapCanvas.getContext('2d');

  // Настройки трассы
  const TRACK_RADIUS = 300;
  const TRACK_WIDTH = 60;
  const R_IN = TRACK_RADIUS - TRACK_WIDTH / 2;
  const R_OUT = TRACK_RADIUS + TRACK_WIDTH / 2;

  // Игрок
  const player = {
    x: TRACK_RADIUS,
    y: 0,
    angle: Math.PI / 2,
    speed: 0,
    steering: 0,
    passedMid: false,
    finished: false
  };

  // ИИ (упрощённый: едет по кругу)
  const ai = {
    angle: Math.PI / 2 - 0.3,
    speed: 2.8,
    passedMid: false,
    finished: false
  };

  let isGas = false, isBrake = false;
  let targetSteering = 0;

  // Управление
  function bindButton(el, down, up) {
    el.addEventListener('touchstart', down);
    el.addEventListener('mousedown', down);
    const end = () => { up(); };
    el.addEventListener('touchend', end);
    el.addEventListener('mouseup', end);
    el.addEventListener('mouseleave', end);
  }

  bindButton(document.getElementById('btn-gas'), () => isGas = true, () => isGas = false);
  bindButton(document.getElementById('btn-brake'), () => isBrake = true, () => isBrake = false);

  // Гироскоп
  if (typeof DeviceOrientationEvent !== 'undefined') {
    window.addEventListener('deviceorientation', (e) => {
      if (state !== 'playing') return;
      if (e.gamma !== null) {
        targetSteering = -e.gamma / 45; // от -1 до +1
      }
    }, { passive: true });
  }

  // Обновление размеров
  function resize() {
    if (state === 'playing') {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      miniMapCanvas.width = 120;
      miniMapCanvas.height = 120;
    } else {
      checkOrientation();
    }
  }

  window.addEventListener('resize', resize);

  // Проверка ориентации
  function checkOrientation() {
    const isLandscape = window.innerWidth > window.innerHeight;
    if (isLandscape && state !== 'playing') {
      document.getElementById('orientation-blocker').classList.remove('active');
      startGame();
    } else {
      setTimeout(checkOrientation, 300);
    }
  }

  // Старт игры
  function startGame() {
    if (state === 'playing') return;
    state = 'playing';

    canvas.style.display = 'block';
    document.getElementById('pause-btn').style.display = 'block';
    document.getElementById('controls').style.display = 'flex';

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    miniMapCanvas.width = 120;
    miniMapCanvas.height = 120;

    // Сброс состояний
    player.x = TRACK_RADIUS;
    player.y = 0;
    player.angle = Math.PI / 2;
    player.speed = 0;
    player.steering = 0;
    player.passedMid = false;
    player.finished = false;

    ai.angle = Math.PI / 2 - 0.3;
    ai.passedMid = false;
    ai.finished = false;

    loop();
  }

  // Главный цикл
  let lastTime = 0;
  function loop(timestamp) {
    if (state !== 'playing') return;

    const delta = Math.min((timestamp - lastTime) / 16, 1); // ~60 FPS
    lastTime = timestamp;

    // Управление
    player.steering += (targetSteering - player.steering) * 5 * delta * 0.016;
    player.angle += player.steering * player.speed * 0.03 * delta;

    if (isGas) player.speed += 80 * delta * 0.016;
    if (isBrake) player.speed -= 90 * delta * 0.016;
    player.speed *= 0.96; // трение
    player.speed = Math.max(-150, Math.min(player.speed, 300));

    // Движение
    player.x += Math.cos(player.angle) * player.speed * delta * 0.016;
    player.y += Math.sin(player.angle) * player.speed * delta * 0.016;

    // Коллизия с краями трассы
    const dist = Math.sqrt(player.x * player.x + player.y * player.y);
    if (dist < R_IN) {
      const dirX = -player.x / dist;
      const dirY = -player.y / dist;
      const push = R_IN - dist + 2;
      player.x += dirX * push;
      player.y += dirY * push;
      player.speed *= 0.8;
    } else if (dist > R_OUT) {
      const dirX = player.x / dist;
      const dirY = player.y / dist;
      const push = dist - R_OUT + 2;
      player.x -= dirX * push;
      player.y -= dirY * push;
      player.speed *= 0.8;
    }

    // Финиш игрока
    const playerAng = Math.atan2(player.y, player.x);
    let normAng = ((playerAng % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
    if (!player.passedMid && normAng > Math.PI - 0.4 && normAng < Math.PI + 0.4) {
      player.passedMid = true;
    }
    const inFinishZone = normAng < 0.2 || normAng > Math.PI * 2 - 0.2;
    const nearStart = Math.abs(player.x - TRACK_RADIUS) < 10 && Math.abs(player.y) < 10;
    if (player.passedMid && inFinishZone && nearStart && !player.finished) {
      player.finished = true;
      if (!ai.finished) showMessage("Вы победили!");
    }

    // ИИ
    ai.angle += ai.speed * delta * 0.016;
    const aiX = Math.cos(ai.angle) * (TRACK_RADIUS - 10);
    const aiY = Math.sin(ai.angle) * (TRACK_RADIUS - 10);

    let aiNorm = ((ai.angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
    if (!ai.passedMid && aiNorm > Math.PI - 0.4 && aiNorm < Math.PI + 0.4) {
      ai.passedMid = true;
    }
    if (ai.passedMid && (aiNorm < 0.2 || aiNorm > Math.PI * 2 - 0.2) && !ai.finished) {
      ai.finished = true;
      if (!player.finished) showMessage("ИИ пришёл первым!");
    }

    // Отрисовка
    render(player.x, player.y, player.angle, aiX, aiY, ai.angle);

    requestAnimationFrame(loop);
  }

  function render(px, py, pAngle, ax, ay, aAngle) {
    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;
    const scale = Math.min(w, h) / 800; // адаптивный масштаб

    // Фон
    ctx.fillStyle = '#336633';
    ctx.fillRect(0, 0, w, h);

    // Дорога
    ctx.strokeStyle = '#444444';
    ctx.lineWidth = TRACK_WIDTH * scale;
    ctx.beginPath();
    ctx.arc(cx, cy, TRACK_RADIUS * scale, 0, Math.PI * 2);
    ctx.stroke();

    // Границы
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, (TRACK_RADIUS - TRACK_WIDTH / 2 + 2) * scale, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(cx, cy, (TRACK_RADIUS + TRACK_WIDTH / 2 - 2) * scale, 0, Math.PI * 2);
    ctx.stroke();

    // Старт/финиш
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(cx + TRACK_RADIUS * scale - 4, cy - 6, 8, 12);

    // Машины — треугольники (нос вперёд!)
    drawCar(px, py, pAngle, '#ff3333');
    drawCar(ax, ay, aAngle, '#33ff33');

    // Мини-карта
    drawMiniMap(px, py, ax, ay);
  }

  function drawCar(x, y, angle, color) {
    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;
    const scale = Math.min(w, h) / 800;

    const screenX = cx + x * scale;
    const screenY = cy + y * scale;

    ctx.save();
    ctx.translate(screenX, screenY);
    ctx.rotate(angle);
    ctx.fillStyle = color;
    // Треугольник: нос вперёд
    ctx.beginPath();
    ctx.moveTo(0, -8);
    ctx.lineTo(-5, 6);
    ctx.lineTo(5, 6);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawMiniMap(px, py, ax, ay) {
    const size = 120;
    const cx = size / 2;
    const cy = size / 2;
    const scale = 0.15;

    miniMapCtx.clearRect(0, 0, size, size);
    miniMapCtx.strokeStyle = '#555';
    miniMapCtx.lineWidth = 6;
    miniMapCtx.beginPath();
    miniMapCtx.arc(cx, cy, TRACK_RADIUS * scale, 0, Math.PI * 2);
    miniMapCtx.stroke();

    miniMapCtx.fillStyle = '#ff0000';
    miniMapCtx.fillRect(cx + TRACK_RADIUS * scale - 1, cy - 2, 2, 4);

    miniMapCtx.fillStyle = '#ff3333';
    miniMapCtx.fillRect(cx + px * scale - 2, cy + py * scale - 2, 4, 4);
    miniMapCtx.fillStyle = '#33ff33';
    miniMapCtx.fillRect(cx + ax * scale - 2, cy + ay * scale - 2, 4, 4);
  }

  function showMessage(text) {
    state = 'finished';
    const msg = document.getElementById('message');
    msg.textContent = text;
    msg.style.opacity = '1';
    setTimeout(() => msg.style.opacity = '0', 3000);
    setTimeout(() => {
      document.getElementById('main-menu').classList.remove('hidden');
      canvas.style.display = 'none';
      document.getElementById('pause-btn').style.display = 'none';
      document.getElementById('controls').style.display = 'none';
    }, 3000);
  }

  // Обработчики кнопок
  document.getElementById('btn-start').addEventListener('click', () => {
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('orientation-blocker').classList.add('active');
    checkOrientation();
  });

  document.getElementById('btn-exit').addEventListener('click', () => {
    window.location.href = 'https://sergeevich11-png.github.io/github.io/';
  });

  document.getElementById('pause-btn').addEventListener('click', () => {
    if (state === 'playing') {
      state = 'paused';
      document.getElementById('main-menu').classList.remove('hidden');
      canvas.style.display = 'none';
      document.getElementById('pause-btn').style.display = 'none';
      document.getElementById('controls').style.display = 'none';
    }
  });

  // Инициализация
  resize();
</script>
