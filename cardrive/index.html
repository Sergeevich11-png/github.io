<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Тест машинки (финал)</title>
  <style>
    body { margin: 0; overflow: hidden; touch-action: none; background: #000; }
    canvas { display: block; }
    #controls {
      position: absolute; bottom: 20px; left: 0; width: 100%;
      display: flex; justify-content: center; gap: 20px; padding: 0 10px;
    }
    .ctrl-btn {
      background: rgba(0, 180, 255, 0.85); border: none; border-radius: 50%;
      color: white; font-size: 28px; font-weight: bold; width: 80px; height: 80px;
      display: flex; justify-content: center; align-items: center;
      user-select: none; -webkit-tap-highlight-color: transparent;
      box-shadow: 0 4px 12px rgba(0, 100, 200, 0.5);
    }
    #speedometer {
      position: absolute; top: 20px; left: 20px;
      background: rgba(0, 0, 0, 0.7); color: white;
      padding: 12px 18px; border-radius: 10px;
      font-family: monospace; font-size: 26px; font-weight: bold;
      z-index: 10; letter-spacing: 1px;
    }
  </style>
</head>
<body>

<div id="controls">
  <button id="btn-up" class="ctrl-btn">▲</button>
  <button id="btn-down" class="ctrl-btn">▼</button>
</div>

<div id="speedometer">000 км/ч</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

const asphalt = new THREE.Mesh(
  new THREE.PlaneGeometry(100, 100),
  new THREE.MeshStandardMaterial({ color: 0x333333 })
);
asphalt.rotation.x = -Math.PI / 2;
scene.add(asphalt);

scene.add(new THREE.AmbientLight(0x666666));
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(10, 20, 10);
scene.add(sun);

const car = new THREE.Group();
const body = new THREE.Mesh(
  new THREE.BoxGeometry(2, 0.8, 4),
  new THREE.MeshPhongMaterial({ color: 0xff3333 })
);
car.add(body);

// Колёса: вертикальные
const wheelRadius = 0.6;
const wheelGeo = new THREE.CylinderGeometry(wheelRadius, wheelRadius, 0.4, 16);
wheelGeo.rotateX(Math.PI / 2);
const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });

const createWheel = (x, z) => {
  const w = new THREE.Mesh(wheelGeo, wheelMat);
  w.position.set(x, -wheelRadius, z);
  return w;
};

const wheelFL = createWheel(-1.1, -1.5);
const wheelFR = createWheel(1.1, -1.5);
const wheelRL = createWheel(-1.1, 1.5);
const wheelRR = createWheel(1.1, 1.5);

car.add(wheelFL, wheelFR, wheelRL, wheelRR);
scene.add(car);

// Ориентиры (столбики)
const poleMat = new THREE.MeshStandardMaterial();
const poleGeo = new THREE.CylinderGeometry(0.3, 0.3, 3, 8);
const addPole = (x, z, color) => {
  const pole = new THREE.Mesh(poleGeo, poleMat.clone());
  pole.material.color.set(color);
  pole.position.set(x, 1.5, z);
  scene.add(pole);
};
for (let x = -50; x <= 50; x += 10) addPole(x, -50, 0x00ff00);
for (let x = -50; x <= 50; x += 10) addPole(x, 50, 0x8B4513);
for (let z = -50; z <= 50; z += 10) addPole(-50, z, 0x9400d3);
for (let z = -50; z <= 50; z += 10) addPole(50, z, 0xff69b4);

const state = { forward: false, backward: false };
const speedometerEl = document.getElementById('speedometer');

const bindTouch = (el, key) => {
  const start = () => { state[key] = true; };
  const end = () => { state[key] = false; };
  el.addEventListener('touchstart', (e) => { e.preventDefault(); start(); }, { passive: false });
  el.addEventListener('mousedown', start);
  el.addEventListener('touchend', end);
  el.addEventListener('mouseup', end);
  el.addEventListener('mouseleave', end);
};

bindTouch(document.getElementById('btn-up'), 'forward');
bindTouch(document.getElementById('btn-down'), 'backward');

// Гироскоп
let initialGamma = null;
let gamma = 0;
const handleOrientation = (e) => {
  if (e.gamma === null) return;
  gamma = e.gamma;
  if (initialGamma === null) initialGamma = e.gamma;
};
if (typeof DeviceOrientationEvent !== 'undefined' && DeviceOrientationEvent.requestPermission) {
  DeviceOrientationEvent.requestPermission().then(permission => {
    if (permission === 'granted') {
      window.addEventListener('deviceorientation', handleOrientation, { passive: true });
    }
  }).catch(console.warn);
} else {
  window.addEventListener('deviceorientation', handleOrientation, { passive: true });
}

// === ФИЗИКА ===
const maxSpeedForward = 23.0;   // 230 км/ч
const maxSpeedBackward = 3.9;   // 39 км/ч
let currentSpeed = 0;
const approachRate = 0.25;
const clock = new THREE.Clock();

function update() {
  const delta = Math.min(clock.getDelta(), 0.1);

  // Поворот
  let steerAngle = 0;
  if (initialGamma !== null) {
    const deltaGamma = gamma - initialGamma;
    const deadZone = 0.35;
    if (Math.abs(deltaGamma) > deadZone) {
      const effective = Math.sign(deltaGamma) * (Math.abs(deltaGamma) - deadZone);
      const normalized = Math.min(1, Math.max(-1, effective / (25 - deadZone)));
      const steerInput = normalized * Math.abs(normalized);
      steerAngle = steerInput * (Math.PI / 4);
    }
  }

  wheelFL.rotation.y = steerAngle;
  wheelFR.rotation.y = steerAngle;
  wheelRL.rotation.y = 0;
  wheelRR.rotation.y = 0;

  // === УПРАВЛЕНИЕ СКОРОСТЬЮ ===
  if (state.forward) {
    currentSpeed += (maxSpeedForward - currentSpeed) * (1 - Math.exp(-approachRate * delta));
  } else if (state.backward) {
    if (currentSpeed > 0.5) {
      currentSpeed -= 2.2 * delta * 60;
      if (currentSpeed < 0) currentSpeed = 0;
    }
    currentSpeed -= (maxSpeedBackward + currentSpeed) * (1 - Math.exp(-approachRate * 1.2 * delta));
    currentSpeed = Math.max(-maxSpeedBackward, currentSpeed);
  } else {
    currentSpeed *= Math.pow(0.94, delta * 60);
  }

  // Ограничение в повороте
  const steerAbs = Math.abs(steerAngle / (Math.PI / 4));
  const effectiveMax = maxSpeedForward * (1 - 0.4 * steerAbs);
  if (currentSpeed > effectiveMax) {
    currentSpeed = effectiveMax;
  }

  // Поворот корпуса
  if (Math.abs(currentSpeed) > 0.1 && Math.abs(steerAngle) > 0.01) {
    const turnRate = (Math.abs(currentSpeed) / maxSpeedForward) * 1.4;
    car.rotation.y -= steerAngle * turnRate * delta;
  }

  // === ПОЗИЦИЯ ===
  const wheelGroundOffset = 0.62;
  car.position.y = wheelGroundOffset;
  const dir = new THREE.Vector3(0, 0, -1).applyEuler(car.rotation);
  car.position.x += dir.x * currentSpeed * delta;
  car.position.z += dir.z * currentSpeed * delta;

  // Камера
  const forward = new THREE.Vector3(0, 0, -1).applyEuler(car.rotation).normalize();
  camera.position.copy(car.position).add(forward.clone().multiplyScalar(-16));
  camera.position.y += 8;
  camera.lookAt(car.position.x, car.position.y + 1.5, car.position.z + forward.z * 5);

  // Спидометр
  const absSpeed = Math.abs(currentSpeed * 10);
  let display = '';
  if (currentSpeed < -0.05) {
    display = `R ${absSpeed.toFixed(0).padStart(3, '0')} км/ч`;
  } else {
    display = `${absSpeed.toFixed(0).padStart(3, '0')} км/ч`;
  }
  speedometerEl.textContent = display;
}

function animate() {
  requestAnimationFrame(animate);
  update();
  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

car.position.set(0, 0.62, 0);
scene.add(car);

animate();
</script>
</body>
</html>
