Я:
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <!-- Мета-теги для мобильного приложения -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Гонки — 1 Круг (Enhanced)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
    body {
      overflow: hidden;
      background: #0d0d0d;
      touch-action: none; /* Важно для сенсорного управления */
      color: white;
    }
    #main-menu {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      z-index: 100; /* Сделаем его выше */
    }
    #main-menu.hidden { display: none; }
    #main-menu h1 {
      font-size: 36px;
      margin-bottom: 50px;
      text-align: center;
      color: #4cc9f0;
      text-shadow: 0 0 10px #1f75fe;
    }
    .btn {
      width: 250px;
      height: 65px;
      margin: 15px 0;
      font-size: 22px;
      font-weight: bold;
      background: #4361ee;
      color: white;
      border: 3px solid #1a2a5a;
      border-radius: 15px;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
    }
    .btn:hover, .btn:active { background: #3a56d4; transform: scale(1.03); }
    #game-canvas {
      display: block;
    }
    #pause-btn {
      position: absolute;
      top: 15px;
      left: 15px;
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #3a56d4;
      border-radius: 10px;
      color: white;
      font-size: 28px;
      cursor: pointer;
      z-index: 50;
    }
    #controls {
      position: absolute;
      bottom: 30px;
      width: 100%;
      display: flex;
      justify-content: space-around;
      padding: 0 20px;
      z-index: 50;
    }
    .ctrl-btn {
      width: 90px;
      height: 90px;
      background: rgba(0, 180, 255, 0.9);
      border: 3px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      color: white;
      font-weight: bold;
      font-size: 18px;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 4px 15px rgba(0, 180, 255, 0.4);
    }
    .ctrl-btn:active { background: #00aaff; }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      color: #ffeb3b;
      padding: 30px 50px;
      border-radius: 20px;
      font-size: 32px;
      font-weight: 900;
      opacity: 0;
      pointer-events: none;
      z-index: 100;
      text-align: center;
      transition: opacity 0.3s;
      border: 5px solid #ffeb3b;
    }
    #mini-map {
      position: absolute;
      top: 15px;
      right: 15px; /* Переместим вправо для лучшего обзора */
      width: 130px;
      height: 130px;
      z-index: 50;
      pointer-events: none;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
    }
  </style>
</head>
<body>

<div id="main-menu">
  <h1>THREE.JS ГОНКИ</h1>
  <button id="btn-start" class="btn">Начать 1 Круг</button>
  <button id="btn-exit" class="btn">Выход (GitHub)</button>
</div>

<canvas id="game-canvas"></canvas>
<canvas id="mini-map"></canvas>
<button id="pause-btn"></button>
<div id="controls">
  <button id="btn-brake" class="ctrl-btn">ТОРМОЗ</button>
  <button id="btn-gas" class="ctrl-btn">ГАЗ</button>
</div>
<div id="message">СООБЩЕНИЕ</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';

// --- Глобальное состояние ---
let state = 'main-menu'; // main-menu, playing, paused, finished
let renderer, scene, camera;

// Позиция и движение машины
let x = 0, z = 0, angle = 0; // angle в радианах (0 = по оси X положительной)
let speed = 0;
let wheelInput = 0; // Угол поворота от гироскопа (-1 до 1)

let isGas = false, isBrake = false;
let passedMid = false; // Флаг, что пройдена половина круга
let finished = false;

// Параметры трассы
const trackRadius = 65; // Радиус центральной линии
const trackWidth = 12;
const R_in = trackRadius - trackWidth / 2; // Внутренний радиус
const R_out = trackRadius + trackWidth / 2; // Внешний радиус

// --- Элементы DOM ---
const mainMenu = document.getElementById('main-menu');
const pauseBtn = document.getElementById('pause-btn');
const gasBtn = document.getElementById('btn-gas');
const brakeBtn = document.getElementById('btn-brake');
const messageEl = document.getElementById('message');
const canvas = document.getElementById('game-canvas');
const miniMapCanvas = document.getElementById('mini-map');
const miniMapCtx = miniMapCanvas.getContext('2d');

// --- Инициализация и Кнопки ---
document.getElementById('btn-start').addEventListener('click', () => {
  mainMenu.classList.add('hidden');
  startGame();
});

document.getElementById('btn-exit').addEventListener('click', () => {
  window.location.href = 'https://sergeevich11-png.github.io/github.io/';
});

pauseBtn.addEventListener('click', () => {
  if (state === 'playing') {
    state = 'paused';
    mainMenu.classList.remove('hidden');
    canvas.style.display = 'none';
    pauseBtn.style.display = 'none';
    document.getElementById('controls').style.display = 'none';
    messageEl.style.opacity = '0'; // Скрываем сообщение о финише, если оно было
  }
});

// Универсальная привязка касания/клика
const bindButton = (el, downAction, upAction) => {
  el.addEventListener('touchstart', (e) => { e.preventDefault(); downAction(); }, { passive: false });
  el.addEventListener('mousedown', downAction);
  
  const end = () => { upAction(); };
  el.addEventListener('touchend', end);
  el.addEventListener('mouseup', end);
  el.addEventListener('mouseleave', end);
};

bindButton(gasBtn, () => isGas = true, () => isGas = false);
bindButton(brakeBtn, () => isBrake = true, () => isBrake = false);

// Запрос разрешения на гироскоп
if (typeof DeviceOrientationEvent !== 'undefined' && DeviceOrientationEvent.requestPermission) {
    DeviceOrientationEvent.requestPermission().then(permissionState => {
        if (permissionState === 'granted') {
            window.addEventListener('deviceorientation', handleOrientation, { passive: true });
        }
    }).catch(console.error);
} else {
    window.addEventListener('deviceorientation', handleOrientation, { passive: true });
}

function handleOrientation(e) {
    if (state === 'playing' && e.gamma !== null) {
        // Чем быстрее едем, тем меньше влияние гамма на руление
        const sensitivityFactor = 0.2 + speed / 8; 
        const clampedGamma = Math.max(-90, Math.min(90, e.gamma));
        wheelInput = (clampedGamma / 90) * 0.6 * sensitivityFactor; 
    }
}

// --- РЕНДЕРИНГ И НАСТРОЙКИ ---

function updateRendererSize() {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', () => { if (state === 'playing') updateRendererSize(); });


// --- ГЕОМЕТРИЯ ТРАССЫ ---

let carMesh;
let frontWheelL, frontWheelR;
const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });

function createCar() {
    // Кузов
    const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff3333

});
    const body = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.55, 2.2), bodyMat);
    
    // Передняя часть (капот)
    const nose = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.3, 0.5), new THREE.MeshPhongMaterial({ color: 0xffff00 }));
    nose.position.set(0, 0.1, -1.0);
    body.add(nose);

    // Колеса
    const wheelGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.5, 12);
    
    // Передние колеса
    frontWheelL = new THREE.Mesh(wheelGeom, wheelMaterial);
    frontWheelL.rotation.z = Math.PI / 2;
    frontWheelL.position.set(-0.8, -0.3, -0.8);
    body.add(frontWheelL);

    frontWheelR = new THREE.Mesh(wheelGeom, wheelMaterial);
    frontWheelR.rotation.z = Math.PI / 2;
    frontWheelR.position.set(0.8, -0.3, -0.8);
    body.add(frontWheelR);

    // Задние колеса (для симметрии, не поворачиваются)
    const rearWheelL = new THREE.Mesh(wheelGeom, wheelMaterial);
    rearWheelL.rotation.z = Math.PI / 2;
    rearWheelL.position.set(-0.8, -0.3, 0.8);
    body.add(rearWheelL);

    const rearWheelR = new THREE.Mesh(wheelGeom, wheelMaterial);
    rearWheelR.rotation.z = Math.PI / 2;
    rearWheelR.position.set(0.8, -0.3, 0.8);
    body.add(rearWheelR);

    return body;
}


function setupScene() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x336633); // Зеленая обочина

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

    renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    updateRendererSize();
    
    // --- СВЕТ ---
    scene.add(new THREE.AmbientLight(0x444444));
    const sun = new THREE.DirectionalLight(0xffffff, 1.5);
    sun.position.set(50, 100, 50);
    scene.add(sun);

    // --- ТРАССА ---
    const roadMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const road = new THREE.Mesh(
        new THREE.RingGeometry(R_in, R_out, 128),
        roadMat
    );
    road.rotation.x = Math.PI / 2; // Поворачиваем плоскость на 90 градусов
    scene.add(road);

    // Разметка (внутренняя и внешняя)
    const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const lineInner = new THREE.Mesh(new THREE.RingGeometry(R_in + 0.5, R_in + 0.6, 128), lineMat);
    lineInner.rotation.x = Math.PI / 2;
    scene.add(lineInner);
    const lineOuter = new THREE.Mesh(new THREE.RingGeometry(R_out - 0.6, R_out - 0.5, 128), lineMat);
    lineOuter.rotation.x = Math.PI / 2;
    scene.add(lineOuter);

    // Бордюры (используем TubeGeometry для более гладких краев)
    const createBarrier = (radius, color) => {
        const points = [];
        for (let i = 0; i <= 128; i++) {
            const a = (i / 128) * Math.PI * 2;
            // Чуть поднимаем бордюр
            points.push(new THREE.Vector3(Math.cos(a) * radius, 0.5, Math.sin(a) * radius));
        }
        const curve = new THREE.CatmullRomCurve3(points);
        curve.closed = true;
        const tube = new THREE.TubeGeometry(curve, 128, 0.5, 10, true);
        const mesh = new THREE.Mesh(tube, new THREE.MeshPhongMaterial({ color: color }));
        scene.add(mesh);
    };
    createBarrier(R_in - 0.6, 0x0066ff); // Внутренний синий
    createBarrier(R_out + 0.6, 0xff0000); // Внешний красный

    // Старт/Финиш линия
    const startLine = new THREE.Mesh(
        new THREE.PlaneGeometry(trackWidth, 1.5),
        new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
    );
    startLine.rotation.x = Math.PI / 2;
    startLine.position.set(trackRadius, 0.55, 0);
    scene.add(startLine);

    // --- МАШИНА ---
    carMesh = createCar();
    scene.add(carMesh);
}


function startGame() {
  if (state === 'playing') return;
  state = 'playing';
  
  canvas.style.display = 'block';
  pauseBtn.style.display = 'block';
  document.getElementById('controls').style.display = 'flex';
  messageEl.style.opacity = '0';

  // Сброс параметров
  x = trackRadius - 3;
  z = 0;
  angle = Math.PI / 2; // Смотрим "вдоль" трассы
  speed = 0;
  wheelInput = 0;
  passedMid = false;
  finished = false;

if (!scene) {
      setupScene();
  }
  
  // Инициализация мини-карты
  setupMiniMap();

  animate();
}

// --- КОЛЛИЗИЯ ---
function constrain(posX, posZ) {
  const d = Math.sqrt(posX * posX + posZ * posZ);
  let collisionMultiplier = 1.0;

  if (d < R_in) {
    // Удар о внутреннюю стенку
    collisionMultiplier = (R_in + 0.5) / d; 
    speed *= 0.80; // Снижаем скорость сильнее
  } else if (d > R_out) {
    // Удар о внешнюю стенку
    collisionMultiplier = (R_out - 0.5) / d;
    speed *= 0.80;
  }
  
  if (collisionMultiplier !== 1.0) {
      posX *= collisionMultiplier; 
      posZ *= collisionMultiplier;
  }
  
  return { x: posX, z: posZ };
}

// --- МИНИ-КАРТА ---
function setupMiniMap() {
    miniMapCanvas.width = 130;
    miniMapCanvas.height = 130;
    const ctx = miniMapCtx;
    const cx = 65, cy = 65;
    const scaleFactor = 120 / (R_out + 5); // Масштабируем, чтобы трек поместился

    ctx.clearRect(0, 0, 130, 130);

    // 1. Рисуем трассу (только один раз)
    ctx.strokeStyle = '#555';
    ctx.lineWidth = trackWidth * scaleFactor;
    ctx.beginPath();
    ctx.arc(cx, cy, trackRadius * scaleFactor, 0, Math.PI * 2);
    ctx.stroke();

    // 2. Рисуем линию старта/финиша
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    const startAngle = Math.PI / 2;
    const endAngle = Math.PI / 2 + 0.05; // Небольшой сегмент
    ctx.arc(cx, cy, trackRadius * scaleFactor + (trackWidth/2) * scaleFactor, startAngle, endAngle);
    ctx.stroke();
    
    // Устанавливаем начальный стиль для машины
    ctx.fillStyle = '#ff3333';
}

function updateMiniMap() {
    const ctx = miniMapCtx;
    const cx = 65, cy = 65;
    const scaleFactor = 120 / (R_out + 5); 

    // Стираем только точку машины (перерисовываем поверх старого фона)
    ctx.fillStyle = '#0d0d0d'; // Цвет фона Canvas
    ctx.fillRect(0, 0, 130, 130);
    
    // Перерисовываем статичные элементы
    ctx.strokeStyle = '#555';
    ctx.lineWidth = trackWidth * scaleFactor;
    ctx.beginPath();
    ctx.arc(cx, cy, trackRadius * scaleFactor, 0, Math.PI * 2);
    ctx.stroke();

    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    const startAngle = Math.PI / 2;
    const endAngle = Math.PI / 2 + 0.05;
    ctx.arc(cx, cy, trackRadius * scaleFactor + (trackWidth/2) * scaleFactor, startAngle, endAngle);
    ctx.stroke();


    // Рисуем машину (квадрат 4x4)
    ctx.fillStyle = '#ff3333';
    ctx.save();
    ctx.translate(cx + x * scaleFactor, cy + z * scaleFactor);
    ctx.rotate(angle + Math.PI / 2);
    ctx.fillRect(-2, -2, 4, 4); // Рисуем квадрат в центре, потом поворачиваем
    ctx.restore();
}


// --- ЦИКЛ РЕНДЕРИНГА ---
function animate() {
  if (state !== 'playing') return;

  const dt = 0.016; // Приблизительное время кадра (1/60 сек)

  // 1. Управление Вводом
  if (isGas) speed += 0.7 * dt * 60;
  if (isBrake) speed -= 0.8 * dt * 60;
  if (!isGas && !isBrake) speed *= Math.pow(0.93, dt * 60); // Экспоненциальное затухание
  
  // Ограничение скорости
  speed = Math.max(-2.0, Math.min(speed, 4.5));

  // 2. Поворот (Зависит от скорости)
  if (Math.abs(speed) > 0.1) {
    // Увеличиваем поворот, если едем быстро, или если wheelInput высок
    const turnRate = 0.8 + Math.abs(speed) * 0.5; 
    angle += wheelInput * turnRate * dt * 10; 
  }

  // 3. Движение
  x += Math.cos(angle) * speed * dt * 15;
  z += Math.sin(angle) * speed * dt * 15;

  // 4. Коллизия и Сброс Скорости при ударе
  const clamped = constrain(x, z);
  x = clamped.x;
  z = clamped.z;
  
  // 5. Визуальные обновления
  
  // Кузов
  carMesh.position.set(x, 0.55, z);
  carMesh.rotation.y = angle + Math.PI / 2;
  
  // Колеса (Визуальный поворот)
  const wheelTurnAngle = wheelInput * 0.8; // Максимальный поворот колес
  frontWheelL.rotation.z = Math.PI / 2 + wheelTurnAngle;
  frontWheelR.rotation.z = Math.PI / 2 + wheelTurnAngle;

// Камера (более плавная, с легким отставанием)
  const targetCameraX = x + Math.cos(angle) * 5 - Math.sin(angle) * 1;
  const targetCameraZ = z + Math.sin(angle) * 5 + Math.cos(angle) * 1;
  
  camera.position.x += (targetCameraX - camera.position.x) * 0.08;
  camera.position.z += (targetCameraZ - camera.position.z) * 0.08;
  camera.position.y = 4 + Math.abs(speed * 0.1); // Чуть приседает на скорости
  
  camera.lookAt(x, 0.7, z); // Смотрим немного вперед по направлению движения

  // 6. Финишная логика
  const curAngle = Math.atan2(z, x);
  // Нормализуем в [0, 2*PI]. 0 градусов это старт/финиш (положительная ось X)
  const normA = ((curAngle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
  
  // Проверка прохождения 180 градусов (середина трека)
  if (!passedMid && normA > Math.PI + 0.3) { 
      passedMid = true;
  }
  
  // Проверка на линии финиша (угол близкий к 0)
  const onFinishLine = normA < 0.3  normA > (Math.PI * 2) - 0.3;
  const nearStartPoint = Math.sqrt(Math.pow(x - trackRadius, 2) + Math.pow(z, 2)) < 3; // Вблизи радиуса и Z=0

  if (passedMid && onFinishLine && nearStartPoint && !finished) {
    finished = true;
    showMessage("КРУГ ЗАВЕРШЕН!");
  }
  
  // 7. Обновление UI
  updateMiniMap();

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

function showMessage(text) {
  messageEl.textContent = text;
  messageEl.style.opacity = '1';
  state = 'finished';
  
  // Пауза и возврат в меню через 3 секунды
  setTimeout(() => {
    messageEl.style.opacity = '0';
    mainMenu.classList.remove('hidden');
    canvas.style.display = 'none';
    pauseBtn.style.display = 'none';
    document.getElementById('controls').style.display = 'none';
  }, 3000);
}
</script>
</body>
</html>
