<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>–¢–µ—Å—Ç –º–∞—à–∏–Ω–∫–∏ (–≥–∏—Ä–æ—Å–∫–æ–ø)</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      touch-action: none;
      background: #000;
    }
    canvas { display: block; }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 0 10px;
      box-sizing: border-box;
    }
    .ctrl-btn {
      background: rgba(0, 180, 255, 0.85);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 28px;
      font-weight: bold;
      width: 80px;
      height: 80px;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 4px 12px rgba(0, 100, 200, 0.5);
    }
  </style>
</head>
<body>

<div id="controls">
  <button id="btn-up" class="ctrl-btn">‚ñ≤</button>
  <button id="btn-down" class="ctrl-btn">‚ñº</button>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

const asphalt = new THREE.Mesh(
  new THREE.PlaneGeometry(100, 100),
  new THREE.MeshStandardMaterial({ color: 0x333333 })
);
asphalt.rotation.x = -Math.PI / 2;
scene.add(asphalt);

scene.add(new THREE.AmbientLight(0x666666));
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(10, 20, 10);
scene.add(sun);

const car = new THREE.Group();
const body = new THREE.Mesh(
  new THREE.BoxGeometry(2, 0.8, 4),
  new THREE.MeshPhongMaterial({ color: 0xff3333 })
);
car.add(body);

const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);
wheelGeo.rotateZ(Math.PI / 2);
const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });

const createWheel = (x, z) => {
  const w = new THREE.Mesh(wheelGeo, wheelMat);
  w.position.set(x, -0.6, z);
  return w;
};

const wheelFL = createWheel(-1.1, -1.5);
const wheelFR = createWheel(1.1, -1.5);
const wheelRL = createWheel(-1.1, 1.5);
const wheelRR = createWheel(1.1, 1.5);

car.add(wheelFL, wheelFR, wheelRL, wheelRR);
scene.add(car);

const poleMat = new THREE.MeshStandardMaterial();
const poleGeo = new THREE.CylinderGeometry(0.3, 0.3, 3, 8);

const addPole = (x, z, color) => {
  const pole = new THREE.Mesh(poleGeo, poleMat.clone());
  pole.material.color.set(color);
  pole.position.set(x, 1.5, z);
  scene.add(pole);
};

for (let x = -50; x <= 50; x += 10) addPole(x, -50, 0x00ff00);
for (let x = -50; x <= 50; x += 10) addPole(x, 50, 0x8B4513);
for (let z = -50; z <= 50; z += 10) addPole(-50, z, 0x9400d3);
for (let z = -50; z <= 50; z += 10) addPole(50, z, 0xff69b4);

const state = { forward: false, backward: false };

const bindTouch = (el, key) => {
  const start = () => { state[key] = true; };
  const end = () => { state[key] = false; };
  el.addEventListener('touchstart', (e) => { e.preventDefault(); start(); }, { passive: false });
  el.addEventListener('mousedown', start);
  el.addEventListener('touchend', end);
  el.addEventListener('mouseup', end);
  el.addEventListener('mouseleave', end);
};

bindTouch(document.getElementById('btn-up'), 'forward');
bindTouch(document.getElementById('btn-down'), 'backward');

// –ì–∏—Ä–æ—Å–∫–æ–ø
let initialGamma = null;
let rawWheelInput = 0;
let wheelInput = 0;

const handleOrientation = (e) => {
  if (e.gamma === null) return;
  if (initialGamma === null) initialGamma = e.gamma;
  const deltaGamma = e.gamma - initialGamma;
  const clamped = Math.max(-25, Math.min(25, deltaGamma));
  const deadZone = 3;
  let input = 0;
  if (Math.abs(clamped) > deadZone) {
    input = (Math.abs(clamped) - deadZone) / (25 - deadZone);
    input *= Math.sign(clamped);
  }
  rawWheelInput = input;
  wheelInput = wheelInput * 0.7 + rawWheelInput * 0.3;
};

if (typeof DeviceOrientationEvent !== 'undefined' && DeviceOrientationEvent.requestPermission) {
  DeviceOrientationEvent.requestPermission().then(permission => {
    if (permission === 'granted') {
      window.addEventListener('deviceorientation', handleOrientation, { passive: true });
    }
  }).catch(console.warn);
} else {
  window.addEventListener('deviceorientation', handleOrientation, { passive: true });
}

// –§–∏–∑–∏–∫–∞
const maxSteerAngle = Math.PI / 5;
let currentSpeed = 0;
const maxSpeed = 8;
const acceleration = 12;
const deceleration = 15;

const clock = new THREE.Clock();

function update() {
  const delta = Math.min(clock.getDelta(), 0.1);

  const steerAngle = wheelInput * maxSteerAngle;
  wheelFL.rotation.z = Math.PI / 2 + steerAngle;
  wheelFR.rotation.z = Math.PI / 2 + steerAngle;

  let targetSpeed = 0;
  if (state.forward) targetSpeed = maxSpeed;
  if (state.backward) targetSpeed = -maxSpeed / 2;

  if (Math.abs(targetSpeed) > 0.1) {
    currentSpeed += (targetSpeed > 0 ? acceleration : -acceleration) * delta;
    currentSpeed = Math.max(-maxSpeed / 2, Math.min(maxSpeed, currentSpeed));
  } else {
    const friction = deceleration * delta;
    if (currentSpeed > friction) currentSpeed -= friction;
    else if (currentSpeed < -friction) currentSpeed += friction;
    else currentSpeed = 0;
  }

  if (Math.abs(currentSpeed) > 0.1 && Math.abs(steerAngle) > 0.01) {
    const turnRate = (currentSpeed / maxSpeed) * 1.8;
    car.rotation.y -= steerAngle * turnRate * delta;
  }

  car.position.y = 0.6;
  const direction = new THREE.Vector3(0, 0, -1).applyEuler(car.rotation);
  car.position.x += direction.x * currentSpeed * delta;
  car.position.z += direction.z * currentSpeed * delta;

  // üî• –ö–ê–ú–ï–†–ê –°–¢–†–û–ì–û –°–õ–ï–î–ò–¢ –°–ó–ê–î–ò
  const forward = new THREE.Vector3(0, 0, -1).applyEuler(car.rotation).normalize();
  const camDistance = 16;
  const camHeight = 8;
  const camOffset = forward.clone().multiplyScalar(-camDistance);
  camera.position.copy(car.position).add(camOffset);
  camera.position.y += camHeight;

  const lookAtPoint = car.position.clone().add(forward.clone().multiplyScalar(5));
  lookAtPoint.y += 1.5;
  camera.lookAt(lookAtPoint);
}

function animate() {
  requestAnimationFrame(animate);
  update();
  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–∑–∏—Ü–∏–∏ –º–∞—à–∏–Ω—ã
car.position.set(0, 0.6, 0);
scene.add(car);

animate();
</script>
</body>
</html>
