<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>–•–æ–¥ –æ—Ç 1 –¥–æ 3</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: Arial, sans-serif; }
    body {
      background: #f8f8f8;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: #222;
      touch-action: manipulation;
    }
    h1 {
      margin: 16px 0;
      font-size: 22px;
      text-align: center;
    }
    .screen { width: 100%; max-width: 400px; }
    .btn {
      width: 100%;
      padding: 12px;
      margin: 6px 0;
      font-size: 17px;
      border: none;
      border-radius: 8px;
      background: #4a90e2;
      color: white;
      cursor: pointer;
    }
    #exitBtn { background: #e74c3c; }
    #langBtn { background: #555; }
    #rulesBtn { background: #27ae60; }
    #board {
      display: grid;
      gap: 2px;
      margin: 16px 0;
      background: #aaa;
      padding: 4px;
      border-radius: 6px;
    }
    .cell {
      aspect-ratio: 1;
      background: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: bold;
    }
    .cell.mine { background: #ffdddd; color: #c00; }
    .cell.player { background: #d0e8ff; }
    .cell.ai { background: #e0e0e0; }
    .cell.free { background: #ffffff; cursor: pointer; }
    .cell.selected { background: #b3d9ff; }
    #status {
      text-align: center;
      font-size: 18px;
      font-weight: bold;
      margin: 12px 0;
      min-height: 24px;
    }
    #passBtn { margin-top: 8px; }
    #rulesModal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #rulesContent {
      background: white;
      padding: 20px;
      border-radius: 10px;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      text-align: left;
    }
    #closeRules {
      margin-top: 12px;
      padding: 8px;
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>–•–æ–¥ –æ—Ç 1 –¥–æ 3</h1>

  <div id="menu" class="screen">
    <button class="btn" onclick="game.startGame(4,5,1)">–õ—ë–≥–∫–∏–π</button>
    <button class="btn" onclick="game.startGame(4,6,2)">–°—Ä–µ–¥–Ω–∏–π</button>
    <button class="btn" onclick="game.startGame(5,6,3)">–°–ª–æ–∂–Ω—ã–π</button>
    <button id="rulesBtn" class="btn" onclick="showRules()">–ü—Ä–∞–≤–∏–ª–∞</button>
    <button id="langBtn" class="btn" onclick="toggleLang()">RU/üåé</button>
    <button id="exitBtn" class="btn" onclick="window.location.href='https://sergeevich11-png.github.io/github.io/'">–í—ã—Ö–æ–¥</button>
  </div>

  <div id="gameScreen" class="screen" style="display:none;">
    <div id="status">–í—ã–±–µ—Ä–∏—Ç–µ 1‚Äì3 —Å–≤—è–∑–Ω—ã–µ –∫–ª–µ—Ç–∫–∏ (–ø–æ —Å—Ç–æ—Ä–æ–Ω–∞–º)</div>
    <div id="board"></div>
    <button id="passBtn" class="btn" disabled>–ü–µ—Ä–µ–¥–∞—Ç—å —Ö–æ–¥</button>
    <button class="btn" style="background:#888;" onclick="game.showMenu()">–ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é</button>
  </div>

  <div id="rulesModal">
    <div id="rulesContent">
      <h2 id="rulesTitle">–ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã</h2>
      <p id="rulesText">–ò–≥—Ä–æ–∫ –∏ –ò–ò –ø–æ –æ—á–µ—Ä–µ–¥–∏ –≤—ã–±–∏—Ä–∞—é—Ç –æ—Ç 1 –¥–æ 3 —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –∫–ª–µ—Ç–æ–∫ (–ø–æ —Å—Ç–æ—Ä–æ–Ω–∞–º, –ù–ï –ü–û –î–ò–ê–ì–û–ù–ê–õ–ò!). –ù–∞ –ø–æ–ª–µ –µ—Å—Ç—å –º–∏–Ω–∞. –¢–æ—Ç, –∫—Ç–æ –≤—ã–±–µ—Ä–µ—Ç –∫–ª–µ—Ç–∫—É —Å –º–∏–Ω–æ–π ‚Äî –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ—Ç. –¶–µ–ª—å ‚Äî –≤—ã–Ω—É–¥–∏—Ç—å –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –ø–æ–ø–∞—Å—Ç—å –Ω–∞ –º–∏–Ω—É.</p>
      <button id="closeRules" onclick="hideRules()">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>
  </div>

  <script>
    const translations = {
      ru: {
        title: "–•–æ–¥ –æ—Ç 1 –¥–æ 3",
        easy: "–õ—ë–≥–∫–∏–π",
        medium: "–°—Ä–µ–¥–Ω–∏–π",
        hard: "–°–ª–æ–∂–Ω—ã–π",
        rules: "–ü—Ä–∞–≤–∏–ª–∞",
        lang: "RU/üåé",
        exit: "–í—ã—Ö–æ–¥",
        backToMenu: "–ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é",
        statusSelect: "–í—ã–±–µ—Ä–∏—Ç–µ 1‚Äì3 —Å–≤—è–∑–Ω—ã–µ –∫–ª–µ—Ç–∫–∏ (–ø–æ —Å—Ç–æ—Ä–æ–Ω–∞–º)",
        passTurn: "–ü–µ—Ä–µ–¥–∞—Ç—å —Ö–æ–¥",
        aiTurn: "–•–æ–¥ –ò–ò...",
        win: "–ò–ò –ø–æ–ø–∞–ª –Ω–∞ –º–∏–Ω—É! –ü–æ–±–µ–¥–∞!",
        lose: "–í—ã –ø–æ–ø–∞–ª–∏ –Ω–∞ –º–∏–Ω—É! –ü–æ—Ä–∞–∂–µ–Ω–∏–µ.",
        rulesTitle: "–ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã",
        rulesText: "–ò–≥—Ä–æ–∫ –∏ –ò–ò –ø–æ –æ—á–µ—Ä–µ–¥–∏ –≤—ã–±–∏—Ä–∞—é—Ç –æ—Ç 1 –¥–æ 3 —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –∫–ª–µ—Ç–æ–∫ (–ø–æ —Å—Ç–æ—Ä–æ–Ω–∞–º, –ù–ï –ü–û –î–ò–ê–ì–û–ù–ê–õ–ò!). –ù–∞ –ø–æ–ª–µ –µ—Å—Ç—å –º–∏–Ω–∞. –¢–æ—Ç, –∫—Ç–æ –≤—ã–±–µ—Ä–µ—Ç –∫–ª–µ—Ç–∫—É —Å –º–∏–Ω–æ–π ‚Äî –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ—Ç. –¶–µ–ª—å ‚Äî –≤—ã–Ω—É–¥–∏—Ç—å –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –ø–æ–ø–∞—Å—Ç—å –Ω–∞ –º–∏–Ω—É."
      },
      en: {
        title: "Move 1 to 3",
        easy: "Easy",
        medium: "Medium",
        hard: "Hard",
        rules: "Rules",
        lang: "EN/üåé",
        exit: "Exit",
        backToMenu: "Back to Menu",
        statusSelect: "Select 1‚Äì3 connected cells (by sides only, NOT diagonally!)",
        passTurn: "Pass Turn",
        aiTurn: "AI's Turn...",
        win: "AI hit the mine! You win!",
        lose: "You hit the mine! Game over.",
        rulesTitle: "Game Rules",
        rulesText: "Player and AI take turns selecting 1 to 3 connected cells (by sides only, NOT diagonally!). There is a mine on the board. Whoever selects the mine loses. Goal: force your opponent to hit the mine."
      }
    };

    let currentLang = 'ru';

    function toggleLang() {
      currentLang = currentLang === 'ru' ? 'en' : 'ru';
      updateUI();
    }

    function showRules() {
      document.getElementById('rulesModal').style.display = 'flex';
    }

    function hideRules() {
      document.getElementById('rulesModal').style.display = 'none';
    }

    function updateUI() {
      const t = translations[currentLang];
      document.title = t.title;
      document.querySelector('h1').textContent = t.title;
      document.querySelectorAll('.btn')[0].textContent = t.easy;
      document.querySelectorAll('.btn')[1].textContent = t.medium;
      document.querySelectorAll('.btn')[2].textContent = t.hard;
      document.getElementById('rulesBtn').textContent = t.rules;
      document.getElementById('langBtn').textContent = t.lang;
      document.getElementById('exitBtn').textContent = t.exit;
      document.querySelector('#gameScreen .btn:last-of-type').textContent = t.backToMenu;
      document.getElementById('passBtn').textContent = t.passTurn;
      document.getElementById('rulesTitle').textContent = t.rulesTitle;
      document.getElementById('rulesText').textContent = t.rulesText;

      if (game.state.gameActive) {
        if (!game.state.playerTurn) {
          game.updateStatus(t.aiTurn);
        } else {
          game.updateStatus(t.statusSelect);
        }
      }
    }

    function isValidMove(selected, newCell) {
      if (selected.length >= 3) return false;
      if (selected.length === 0) return true;
      return selected.some(p =>
        (Math.abs(p.r - newCell.r) === 1 && p.c === newCell.c) ||
        (Math.abs(p.c - newCell.c) === 1 && p.r === newCell.r)
      );
    }

    function generateAllConnectedGroups(freeCells, rows, cols) {
      const freeSet = new Set(freeCells.map(p => `${p.r},${p.c}`));
      const groups = [];
      const dirs = [[-1,0],[1,0],[0,-1],[0,1]];

      for (const p of freeCells) groups.push([p]);

      for (const p of freeCells) {
        for (const [dr,dc] of dirs) {
          const n = {r: p.r+dr, c: p.c+dc};
          if (freeSet.has(`${n.r},${n.c}`)) {
            const key = [`${p.r},${p.c}`, `${n.r},${n.c}`].sort().join('|');
            if (!groups.some(g => g.length === 2 && g.map(x => `${x.r},${x.c}`).sort().join('|') === key)) {
              groups.push([p, n]);
            }
          }
        }
      }

      for (const pair of groups.filter(g => g.length === 2)) {
        const used = new Set(pair.map(p => `${p.r},${p.c}`));
        for (const p of pair) {
          for (const [dr,dc] of dirs) {
            const n = {r: p.r+dr, c: p.c+dc};
            const key = `${n.r},${n.c}`;
            if (freeSet.has(key) && !used.has(key)) {
              const triple = [...pair, n];
              const tKey = triple.map(x => `${x.r},${x.c}`).sort().join('|');
              if (!groups.some(g => g.length === 3 && g.map(x => `${x.r},${x.c}`).sort().join('|') === tKey)) {
                groups.push(triple);
              }
            }
          }
        }
      }

      return groups;
    }

    function countFreeCells(board) {
      let count = 0;
      for (let r = 0; r < board.length; r++)
        for (let c = 0; c < board[r].length; c++)
          if (board[r][c] === null) count++;
      return count;
    }

    function getFreeCells(board) {
      const cells = [];
      for (let r = 0; r < board.length; r++)
        for (let c = 0; c < board[r].length; c++)
          if (board[r][c] === null) cells.push({r, c});
      return cells;
    }

    function cloneBoard(board) {
      return board.map(row => [...row]);
    }

    function evaluatePosition(board, minePos, isAITurn) {
      const free = getFreeCells(board);
      const freeCount = free.length;
      if (freeCount === 0) return isAITurn ? -100 : 100;

      const parityScore = (freeCount % 2 === 0) ? -10 : 10;
      const visited = new Set();
      let components = 0;
      const freeSet = new Set(free.map(p => `${p.r},${p.c}`));
      const dirs = [[-1,0],[1,0],[0,-1],[0,1]];

      for (const p of free) {
        const key = `${p.r},${p.c}`;
        if (visited.has(key)) continue;
        components++;
        const stack = [p];
        while (stack.length) {
          const cur = stack.pop();
          const curKey = `${cur.r},${cur.c}`;
          if (visited.has(curKey)) continue;
          visited.add(curKey);
          for (const [dr,dc] of dirs) {
            const nb = {r: cur.r+dr, c: cur.c+dc};
            const nbKey = `${nb.r},${nb.c}`;
            if (freeSet.has(nbKey) && !visited.has(nbKey)) {
              stack.push(nb);
            }
          }
        }
      }
      const fragScore = components * 5;

      const playerGroups = generateAllConnectedGroups(free, board.length, board[0].length);
      let maxPlayerLen = 0;
      for (const g of playerGroups) {
        if (g.length > maxPlayerLen) maxPlayerLen = g.length;
      }
      const moveLenScore = (3 - maxPlayerLen) * 4;

      return parityScore + fragScore + moveLenScore;
    }

    function minimax(board, minePos, depth, alpha, beta, isMaximizing, rows, cols) {
      const freeCount = countFreeCells(board);
      if (depth === 0 || freeCount === 0) {
        return { score: evaluatePosition(board, minePos, !isMaximizing) };
      }

      const freeCells = getFreeCells(board).filter(p => !(p.r === minePos.r && p.c === minePos.c));
      const allGroups = generateAllConnectedGroups(freeCells, rows, cols);

      if (allGroups.length === 0) {
        return { score: isMaximizing ? -100 : 100 };
      }

      let bestScore = isMaximizing ? -Infinity : Infinity;
      let bestMove = allGroups[0];

      for (const group of allGroups) {
        const newBoard = cloneBoard(board);
        for (const p of group) newBoard[p.r][p.c] = isMaximizing ? 'ai' : 'player';

        const result = minimax(newBoard, minePos, depth - 1, alpha, beta, !isMaximizing, rows, cols);

        if (isMaximizing) {
          if (result.score > bestScore) {
            bestScore = result.score;
            bestMove = group;
          }
          alpha = Math.max(alpha, bestScore);
        } else {
          if (result.score < bestScore) {
            bestScore = result.score;
            bestMove = group;
          }
          beta = Math.min(beta, bestScore);
        }

        if (beta <= alpha) break;
      }

      return { score: bestScore, move: bestMove };
    }

    class MineGame {
      constructor() {
        this.state = this.resetState();
        this.ui = {
          menu: document.getElementById('menu'),
          gameScreen: document.getElementById('gameScreen'),
          board: document.getElementById('board'),
          status: document.getElementById('status'),
          passBtn: document.getElementById('passBtn')
        };
        this.init();
      }

      resetState() {
        return {
          rows: 0,
          cols: 0,
          difficulty: 1,
          board: [],
          minePos: { r: -1, c: -1 },
          gameActive: false,
          playerTurn: true,
          selectedCells: []
        };
      }

      init() {
        this.ui.passBtn.addEventListener('click', () => this.passTurn());
      }

      showMenu() {
        this.ui.menu.style.display = 'block';
        this.ui.gameScreen.style.display = 'none';
        this.state.gameActive = false;
        this.state = this.resetState();
      }

      startGame(rows, cols, difficulty) {
        this.state = this.resetState();
        this.state.rows = rows;
        this.state.cols = cols;
        this.state.difficulty = difficulty;
        this.state.board = Array(rows).fill().map(() => Array(cols).fill(null));
        this.state.minePos = {
          r: Math.floor(Math.random() * rows),
          c: Math.floor(Math.random() * cols)
        };
        this.state.board[this.state.minePos.r][this.state.minePos.c] = 'mine';
        this.state.gameActive = true;
        this.state.playerTurn = true;
        this.state.selectedCells = [];

        this.ui.menu.style.display = 'none';
        this.ui.gameScreen.style.display = 'block';
        this.ui.passBtn.disabled = true;
        this.updateStatus(translations[currentLang].statusSelect);

        this.ui.board.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        this.ui.board.innerHTML = '';

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            if (this.state.board[r][c] === 'mine') {
              cell.classList.add('mine');
              cell.textContent = 'üí£';
            }
            this.ui.board.appendChild(cell);
          }
        }

        this.renderAll();
      }

      renderCell(r, c) {
        const idx = r * this.state.cols + c;
        const cell = this.ui.board.children[idx];
        if (!cell) return;

        cell.className = 'cell';
        cell.textContent = '';

        const val = this.state.board[r][c];
        if (val === 'mine') {
          cell.classList.add('mine');
          cell.textContent = 'üí£';
        } else if (val === 'player') {
          cell.classList.add('player');
          cell.textContent = '‚óè';
        } else if (val === 'ai') {
          cell.classList.add('ai');
          cell.textContent = '‚óã';
        } else if (this.state.playerTurn && this.state.gameActive) {
          cell.classList.add('free');
          cell.onclick = () => this.toggleCell(r, c);
        } else {
          cell.onclick = null;
        }

        if (this.state.selectedCells.some(p => p.r === r && p.c === c)) {
          cell.classList.add('selected');
        }
      }

      renderAll() {
        for (let r = 0; r < this.state.rows; r++) {
          for (let c = 0; c < this.state.cols; c++) {
            this.renderCell(r, c);
          }
        }
      }

      toggleCell(r, c) {
        if (!this.state.playerTurn || !this.state.gameActive || this.state.board[r][c] !== null) return;

        const idx = this.state.selectedCells.findIndex(p => p.r === r && p.c === c);
        if (idx >= 0) {
          this.state.selectedCells.splice(idx, 1);
        } else {
          if (!isValidMove(this.state.selectedCells, {r, c})) return;
          this.state.selectedCells.push({ r, c });
        }

        this.renderAll();
        this.ui.passBtn.disabled = this.state.selectedCells.length === 0;
      }

      passTurn() {
        if (!this.state.gameActive || this.state.selectedCells.length === 0) return;

        const hitMine = this.state.selectedCells.some(p => 
          p.r === this.state.minePos.r && p.c === this.state.minePos.c
        );

        if (hitMine) {
          this.state.selectedCells.forEach(p => {
            this.state.board[p.r][p.c] = 'player';
          });
          this.renderAll();
          this.endGame(false);
          return;
        }

        this.state.selectedCells.forEach(p => {
            this.state.board[p.r][p.c] = 'player';
        });
        this.state.selectedCells = [];

        const free = countFreeCells(this.state.board);
        if (free === 0) {
          setTimeout(() => {
            this.state.board[this.state.minePos.r][this.state.minePos.c] = 'ai';
            this.renderAll();
            this.endGame(true);
          }, 600);
          return;
        }

        this.state.playerTurn = false;
        this.updateStatus(translations[currentLang].aiTurn);
        this.ui.passBtn.disabled = true;
        setTimeout(() => this.aiTurn(), 800);
      }

      aiTurn() {
        if (!this.state.gameActive) return;

        const freeCells = getFreeCells(this.state.board);
        if (freeCells.length === 0) {
          this.updateStatus('No moves');
          this.state.gameActive = false;
          return;
        }

        let aiGroup;

        if (this.state.difficulty === 1) {
          const allGroups = generateAllConnectedGroups(freeCells, this.state.rows, this.state.cols);
          aiGroup = allGroups.length ? allGroups[Math.floor(Math.random() * allGroups.length)] : [freeCells[0]];
        } else if (this.state.difficulty === 2) {
          const safeGroups = generateAllConnectedGroups(freeCells, this.state.rows, this.state.cols)
            .filter(g => !g.some(p => p.r === this.state.minePos.r && p.c === this.state.minePos.c));
          if (safeGroups.length === 0) {
            aiGroup = [freeCells[0]];
          } else {
            let best = [];
            let bestParity = -1;
            for (const g of safeGroups) {
              const rem = freeCells.length - g.length;
              const odd = rem % 2;
              if (odd > bestParity) {
                bestParity = odd;
                best = [g];
              } else if (odd === bestParity) {
                best.push(g);
              }
            }
            aiGroup = best[Math.floor(Math.random() * best.length)];
          }
        } else if (this.state.difficulty === 3) {
          const safeGroups = generateAllConnectedGroups(freeCells, this.state.rows, this.state.cols)
            .filter(g => !g.some(p => p.r === this.state.minePos.r && p.c === this.state.minePos.c));
          if (safeGroups.length === 0) {
            aiGroup = [freeCells[0]];
          } else {
            const result = minimax(
              this.state.board,
              this.state.minePos,
              2,
              -Infinity,
              Infinity,
              true,
              this.state.rows,
              this.state.cols
            );
            aiGroup = result.move;
          }
        }

        const hitMine = aiGroup.some(p => p.r === this.state.minePos.r && p.c === this.state.minePos.c);
        aiGroup.forEach(p => {
          this.state.board[p.r][p.c] = 'ai';
        });
        this.renderAll();

        if (hitMine) {
          this.endGame(true);
          return;
        }

        const free = countFreeCells(this.state.board);
        if (free === 0) {
          setTimeout(() => {
            this.state.board[this.state.minePos.r][this.state.minePos.c] = 'player';
            this.renderAll();
            this.endGame(false);
          }, 1000);
          return;
        }

        this.state.playerTurn = true;
        this.updateStatus(translations[currentLang].statusSelect);
        this.ui.passBtn.disabled = this.state.selectedCells.length === 0;
        this.renderAll();
      }

      updateStatus(text) {
        this.ui.status.textContent = text;
      }

      endGame(playerWon) {
        this.state.gameActive = false;
        const t = translations[currentLang];
        if (playerWon) {
          this.updateStatus(t.win);
        } else {
          this.updateStatus(t.lose);
        }
        setTimeout(() => this.showMenu(), 2000);
      }
    }

    const game = new MineGame();
  </script>
</body>
</html>
