<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0" />
  <title>Шарики-рикошет</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #d6e2eb;
      font-family: sans-serif;
      user-select: none;
    }
    #gameCanvas {
      display: block;
      background: #d6e2eb;
      width: 100%;
      height: 100%;
    }
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* делает весь UI "прозрачным" для касаний по умолчанию */
    }
    .screen {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      padding: 20px;
      pointer-events: auto; /* но активные экраны получают события */
    }
    .screen.active {
      display: flex;
    }
    button {
      padding: 14px 28px;
      font-size: 18px;
      background: #4a90e2;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      pointer-events: auto;
      margin: 10px;
      width: 80%;
      max-width: 300px;
    }
    .menu-btn {
      position: absolute;
      top: 15px;
      left: 15px;
      padding: 8px 16px;
      font-size: 16px;
      background: rgba(0,0,0,0.5);
      color: white;
      border: none;
      border-radius: 8px;
      pointer-events: auto;
      z-index: 10;
    }
    .timer {
      position: absolute;
      top: 15px;
      right: 15px;
      font-size: 18px;
      background: rgba(255,255,255,0.8);
      padding: 6px 12px;
      border-radius: 8px;
      pointer-events: auto;
      z-index: 10;
    }
    .queue-container {
      position: absolute;
      bottom: 30px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      pointer-events: auto;
    }
    .ball-queue {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid white;
    }
    .ball-in-cannon {
      position: absolute;
      bottom: 30px;
      left: 55px;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid white;
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="ui">
    <div id="mainMenu" class="screen active">
      <h2 style="font-size: 24px; margin-bottom: 20px; color: #333;">Шарики-рикошет</h2>
      <button id="btnDifficulty">Сложность: Средне</button>
      <button id="btnPlay">Играть</button>
      <button id="btnExit">Выход</button>
    </div>

    <div id="levelSelect" class="screen">
      <h2 style="font-size: 24px; margin-bottom: 20px;">Уровень</h2>
      <div style="display: flex; gap: 10px; margin: 10px 0;">
        <button id="btnPrev">←</button>
        <button id="btnCurrent">1</button>
        <button id="btnNext">→</button>
      </div>
      <button id="btnStartLevel">Начать</button>
      <button id="btnBackToMenu">Назад</button>
    </div>

    <div id="inGameUI" class="screen">
      <div class="timer" id="timer">00:00</div>
      <button class="menu-btn" id="btnBackToMenuInGame">Назад</button>
      <div class="queue-container" id="queueDisplay"></div>
      <div class="ball-in-cannon" id="cannonBall"></div>
    </div>

    <div id="victoryScreen" class="screen">
      <h2 style="font-size: 24px;">Победа!</h2>
      <div id="starsDisplay" style="font-size: 32px; margin: 15px 0;">⭐⭐⭐</div>
      <div id="timeDisplay" style="font-size: 18px;">Время: 00:00</div>
      <button id="btnNextLevel">Следующий уровень</button>
      <button id="btnReplay">Повторить</button>
      <button id="btnToMenuVictory">В меню</button>
    </div>

    <div id="gameOverScreen" class="screen">
      <h2 style="font-size: 24px;">Поражение!</h2>
      <button id="btnRetry">Повторить</button>
      <button id="btnToMenuGameOver">В меню</button>
    </div>
  </div>

  <script>
    // ======================
    // Адаптивный canvas
    // ======================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      const displayWidth = window.innerWidth;
      const displayHeight = window.innerHeight;
      
      const aspectRatio = 9 / 15;
      let width, height;
      
      if (displayWidth / displayHeight > aspectRatio) {
        height = displayHeight;
        width = height * aspectRatio;
      } else {
        width = displayWidth;
        height = width / aspectRatio;
      }

      canvas.width = width;
      canvas.height = height;

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      canvas.style.margin = 'auto';
      canvas.style.position = 'absolute';
      canvas.style.top = '50%';
      canvas.style.left = '50%';
      canvas.style.transform = 'translate(-50%, -50%)';
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ======================
    // Конфигурация
    // ======================
    const COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'];
    const BALL_RADIUS = canvas.height * 0.01875;
    const CANNON_X = canvas.width / 2;
    const CANNON_Y = canvas.height - canvas.height * 0.0625;
    const DEATH_LINE_Y = CANNON_Y - canvas.height * 0.125;
    const MAX_LEVELS = 100;
    const TIME_LIMIT = 5 * 60 * 1000;

    function randomColor() {
      return COLORS[Math.floor(Math.random() * COLORS.length)];
    }

    function formatTime(ms) {
      const totalSec = Math.floor(ms / 1000);
      const min = Math.floor(totalSec / 60).toString().padStart(2, '0');
      const sec = (totalSec % 60).toString().padStart(2, '0');
      return `${min}:${sec}`;
    }

    function getStars(timeMs) {
      if (timeMs <= 3 * 60 * 1000) return 3;
      if (timeMs <= 4 * 60 * 1000) return 2;
      if (timeMs <= 5 * 60 * 1000) return 1;
      return 0;
    }

    // ======================
    // Классы
    // ======================
    class Ball {
      constructor(x, y, color, isFalling = false) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.isFalling = isFalling;
        this.radius = BALL_RADIUS;
      }

      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
      }
    }

    class LevelBuffer {
      constructor() {
        this.levels = [];
      }

      get(id) {
        return this.levels.find(l => l.id === id);
      }

      save(id, structure, stars = null) {
        if (this.get(id)) return;
        this.levels.push({ id, structure: [...structure], stars });
        if (this.levels.length > 3) this.levels.shift();
      }

      setStars(id, stars) {
        const level = this.get(id);
        if (level) level.stars = stars;
      }
    }

    class Queue {
      constructor(difficulty) {
        this.difficulty = difficulty;
        this.colors = [];
        this.refill();
      }

      refill() {
        while (this.colors.length < this.difficulty) {
          this.colors.push(randomColor());
        }
      }

      currentColor() {
        return this.colors[0] || randomColor();
      }

      pop() {
        const color = this.colors.shift();
        this.colors.push(randomColor());
        return color;
      }

      nextColors() {
        return this.colors.slice(1);
      }
    }

    class Structure {
      constructor() {
        this.balls = [];
      }

      add(ball) {
        this.balls.push(ball);
      }

      removeGroup(group) {
        const removed = [];
        for (let ball of group) {
          const idx = this.balls.indexOf(ball);
          if (idx !== -1) {
            removed.push({ x: ball.x, y: ball.y });
            this.balls.splice(idx, 1);
          }
        }
        return removed;
      }

      findConnected(startBall) {
        const visited = new Set();
        const stack = [startBall];
        const group = [];
        const targetColor = startBall.color;

        while (stack.length > 0) {
          const current = stack.pop();
          if (visited.has(current)) continue;
          visited.add(current);
          if (current.color === targetColor) {
            group.push(current);
            for (let other of this.balls) {
              if (visited.has(other)) continue;
              const dx = other.x - current.x;
              const dy = other.y - current.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist <= BALL_RADIUS * 2 + 2) {
                stack.push(other);
              }
            }
          }
        }
        return group.length >= 3 ? group : [];
      }

      updateConnectedness() {
        if (this.balls.length === 0) return;

        let minY = Infinity;
        for (let b of this.balls) if (b.y < minY) minY = b.y;

        const rootBalls = this.balls.filter(b => Math.abs(b.y - minY) <= BALL_RADIUS);
        const connected = new Set();
        const queue = [...rootBalls];
        for (let b of rootBalls) connected.add(b);

        while (queue.length > 0) {
          const current = queue.shift();
          for (let other of this.balls) {
            if (connected.has(other)) continue;
            const dx = other.x - current.x;
            const dy = other.y - current.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= BALL_RADIUS * 2 + 2) {
              connected.add(other);
              queue.push(other);
            }
          }
        }

        for (let b of this.balls) b.isFalling = !connected.has(b);
      }

      checkGameOver(deathLineY) {
        for (let b of this.balls) {
          if (!b.isFalling && b.y + b.radius >= deathLineY) return true;
        }
        return false;
      }

      collectFalling() {
        const falling = this.balls.filter(b => b.isFalling);
        this.balls = this.balls.filter(b => !b.isFalling);
        return falling;
      }
    }

    // ======================
    // Игровое состояние
    // ======================
    const levelBuffer = new LevelBuffer();
    let gameState = {
      mode: 'menu',
      difficulty: 2,
      currentLevel: 1,
      queue: null,
      structure: null,
      startTime: null,
      elapsedTime: 0,
      cannonAngle: 0,
      isAiming: false,
      aimPoint: { x: 0, y: 0 },
      fallingBalls: [],
      lastFrame: 0
    };

    // ======================
    // Генерация уровня
    // ======================
    function generateLevelStructure(levelId) {
      const structure = new Structure();
      const rows = 3 + Math.min(2, Math.floor(levelId / 20));
      const cols = 8;
      const startX = canvas.width / 2 - (cols * BALL_RADIUS * 2) / 2 + BALL_RADIUS;
      const startY = canvas.height * 0.125;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          if (Math.random() < 0.2) continue;
          const x = startX + col * BALL_RADIUS * 2;
          const y = startY + row * BALL_RADIUS * 2;
          structure.add(new Ball(x, y, randomColor()));
        }
      }
      return structure;
    }

    // ======================
    // Отрисовка
    // ======================
    function drawBackground() {
      ctx.fillStyle = '#d6e2eb';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawCannon() {
      ctx.save();
      ctx.translate(CANNON_X, CANNON_Y);
      ctx.rotate(gameState.cannonAngle);
      ctx.beginPath();
      ctx.moveTo(-12, 0);
      ctx.lineTo(12, 0);
      ctx.lineTo(6, -35);
      ctx.lineTo(-6, -35);
      ctx.closePath();
      ctx.fillStyle = '#555';
      ctx.fill();
      ctx.restore();
    }

    function drawAimLine() {
      if (!gameState.isAiming) return;

      const points = [];
      let x = CANNON_X;
      let y = CANNON_Y;
      const dx = gameState.aimPoint.x - CANNON_X;
      const dy = gameState.aimPoint.y - CANNON_Y;
      const angle = Math.atan2(dx, -dy);
      let vx = Math.sin(angle) * 10;
      let vy = -Math.cos(angle) * 10;
      let length = 0;
      const maxLength = canvas.height * 0.6;

      while (length < maxLength) {
        x += vx;
        y += vy;
        length += Math.sqrt(vx * vx + vy * vy);

        if (x <= BALL_RADIUS) {
          x = BALL_RADIUS;
          vx = -vx;
        } else if (x >= canvas.width - BALL_RADIUS) {
          x = canvas.width - BALL_RADIUS;
          vx = -vx;
        }

        points.push({ x, y });

        if (y <= canvas.height * 0.1) break;
      }

      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.setLineDash([6, 4]);
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawDeathLine() {
      ctx.strokeStyle = '#ff000044';
      ctx.setLineDash([10, 5]);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, DEATH_LINE_Y);
      ctx.lineTo(canvas.width, DEATH_LINE_Y);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawFallingBalls() {
      for (let ball of gameState.fallingBalls) {
        ball.draw(ctx);
      }
    }

    function render() {
      drawBackground();
      if (gameState.mode === 'playing') {
        drawDeathLine();
        drawAimLine();
        gameState.structure.balls.forEach(b => b.draw(ctx));
        drawFallingBalls();
        drawCannon();
        ctx.beginPath();
        ctx.arc(
          CANNON_X + Math.sin(gameState.cannonAngle) * 40,
          CANNON_Y - Math.cos(gameState.cannonAngle) * 40,
          BALL_RADIUS,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = gameState.queue.currentColor();
        ctx.fill();
      }
    }

    // ======================
    // Обновление и выстрел
    // ======================
    function shoot() {
      if (gameState.mode !== 'playing' || !gameState.isAiming) return;

      const color = gameState.queue.pop();
      const dx = gameState.aimPoint.x - CANNON_X;
      const dy = gameState.aimPoint.y - CANNON_Y;
      const angle = Math.atan2(dx, -dy);
      const speed = canvas.height * 0.01;
      let x = CANNON_X;
      let y = CANNON_Y;
      let vx = Math.sin(angle) * speed;
      let vy = -Math.cos(angle) * speed;

      function moveBall() {
        x += vx;
        y += vy;

        if (x <= BALL_RADIUS || x >= canvas.width - BALL_RADIUS) {
          vx = -vx;
          x = Math.max(BALL_RADIUS, Math.min(canvas.width - BALL_RADIUS, x));
        }

        let collided = false;
        for (let ball of gameState.structure.balls) {
          const dx = x - ball.x;
          const dy = y - ball.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= BALL_RADIUS * 2) {
            const nx = dx / dist;
            const ny = dy / dist;
            const attachX = ball.x + nx * BALL_RADIUS * 2;
            const attachY = ball.y + ny * BALL_RADIUS * 2;
            const newBall = new Ball(attachX, attachY, color);
            gameState.structure.add(newBall);

            const group = gameState.structure.findConnected(newBall);
            if (group.length >= 3) {
              gameState.structure.removeGroup(group);
            }

            gameState.structure.updateConnectedness();
            const falling = gameState.structure.collectFalling();
            gameState.fallingBalls = falling.map(b => ({ ...b, vy: canvas.height * 0.003 }));

            collided = true;
            break;
          }
        }

        if (!collided && y <= canvas.height * 0.1) {
          const newBall = new Ball(x, canvas.height * 0.1, color);
          gameState.structure.add(newBall);
          collided = true;
        }

        if (collided) {
          if (gameState.structure.checkGameOver(DEATH_LINE_Y)) {
            gameState.mode = 'gameOver';
            showScreen('gameOverScreen');
            return;
          }

          if (gameState.structure.balls.length === 0) {
            const time = Date.now() - gameState.startTime;
            const stars = getStars(time);
            levelBuffer.setStars(gameState.currentLevel, stars);
            gameState.mode = 'victory';
            document.getElementById('timeDisplay').textContent = `Время: ${formatTime(time)}`;
            document.getElementById('starsDisplay').textContent = '⭐'.repeat(stars);
            showScreen('victoryScreen');
            return;
          }

          updateQueueDisplay();
          return;
        }

        requestAnimationFrame(moveBall);
      }

      moveBall();
    }

    function updateFallingBalls(deltaTime) {
      const gravity = canvas.height * 0.0001;
      for (let i = gameState.fallingBalls.length - 1; i >= 0; i--) {
        const ball = gameState.fallingBalls[i];
        ball.vy += gravity;
        ball.y += ball.vy;
        if (ball.y > canvas.height + 100) {
          gameState.fallingBalls.splice(i, 1);
        }
      }
    }

    function gameLoop(timestamp) {
      const deltaTime = timestamp - gameState.lastFrame;
      gameState.lastFrame = timestamp;

      if (gameState.mode === 'playing') {
        gameState.elapsedTime = Date.now() - gameState.startTime;
        document.getElementById('timer').textContent = formatTime(gameState.elapsedTime);

        if (gameState.elapsedTime > TIME_LIMIT) {
          gameState.mode = 'gameOver';
          showScreen('gameOverScreen');
          return;
        }

        updateFallingBalls(deltaTime);
      }

      render();
      requestAnimationFrame(gameLoop);
    }

    // ======================
    // UI
    // ======================
    function showScreen(id) {
      document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
      document.getElementById(id).classList.add('active');
    }

    function startGame() {
      const levelData = levelBuffer.get(gameState.currentLevel);
      let structure;
      if (levelData) {
        structure = new Structure();
        structure.balls = levelData.structure.map(b => new Ball(b.x, b.y, b.color));
      } else {
        structure = generateLevelStructure(gameState.currentLevel);
        levelBuffer.save(gameState.currentLevel, structure.balls);
      }

      gameState.mode = 'playing';
      gameState.structure = structure;
      gameState.queue = new Queue(gameState.difficulty);
      gameState.startTime = Date.now();
      gameState.elapsedTime = 0;
      gameState.fallingBalls = [];
      gameState.cannonAngle = 0;
      gameState.isAiming = false;
      document.getElementById('timer').textContent = '00:00';
      updateQueueDisplay();
      showScreen('inGameUI');
    }

    function updateQueueDisplay() {
      const container = document.getElementById('queueDisplay');
      container.innerHTML = '';
      const next = gameState.queue.nextColors();
      for (let color of next) {
        const div = document.createElement('div');
        div.className = 'ball-queue';
        div.style.backgroundColor = color;
        container.appendChild(div);
      }

      const cannonBall = document.getElementById('cannonBall');
      cannonBall.style.backgroundColor = gameState.queue.currentColor();
    }

    // ======================
    // Обработка касаний — ПЕРЕНЕСЕНА НА DOCUMENT
    // ======================
    function getCanvasCoords(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / canvas.clientWidth;
      const scaleY = canvas.height / canvas.clientHeight;
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }

    function handleTouchStart(e) {
      if (gameState.mode !== 'playing') return;
      if (e.touches.length === 0) return;
      e.preventDefault();
      const touch = e.touches[0];
      const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
      gameState.isAiming = true;
      gameState.aimPoint = { x, y };
      gameState.cannonAngle = Math.atan2(x - CANNON_X, -(y - CANNON_Y));
    }

    function handleTouchMove(e) {
      if (!gameState.isAiming || gameState.mode !== 'playing') return;
      if (e.touches.length === 0) return;
      e.preventDefault();
      const touch = e.touches[0];
      const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
      gameState.aimPoint = { x, y };
      gameState.cannonAngle = Math.atan2(x - CANNON_X, -(y - CANNON_Y));
    }

    function handleTouchEnd(e) {
      if (gameState.mode !== 'playing') return;
      e.preventDefault();
      if (gameState.isAiming) {
        shoot();
      }
      gameState.isAiming = false;
    }

    // ✅ Ключевое изменение: слушаем события на document
    document.addEventListener('touchstart', handleTouchStart, { passive: false });
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleTouchEnd, { passive: false });
    document.addEventListener('touchcancel', () => { gameState.isAiming = false; }, { passive: false });

    // ======================
    // Кнопки
    // ======================
    document.getElementById('btnExit').addEventListener('click', () => {});
    document.getElementById('btnDifficulty').addEventListener('click', () => {
      const btn = document.getElementById('btnDifficulty');
      gameState.difficulty = gameState.difficulty % 3 + 1;
      const labels = { 1: 'Сложно', 2: 'Средне', 3: 'Легко' };
      btn.textContent = `Сложность: ${labels[gameState.difficulty]}`;
    });
    document.getElementById('btnPlay').addEventListener('click', () => showScreen('levelSelect'));

    const levelBtn = document.getElementById('btnCurrent');
    const prevBtn = document.getElementById('btnPrev');
    const nextBtn = document.getElementById('btnNext');

    function updateLevelButtons() {
      levelBtn.textContent = gameState.currentLevel;
      prevBtn.disabled = gameState.currentLevel === 1;
      nextBtn.disabled = gameState.currentLevel === MAX_LEVELS;
    }

    prevBtn.addEventListener('click', () => {
      if (gameState.currentLevel > 1) {
        gameState.currentLevel--;
        updateLevelButtons();
      }
    });

    nextBtn.addEventListener('click', () => {
      if (gameState.currentLevel < MAX_LEVELS) {
        gameState.currentLevel++;
        updateLevelButtons();
      }
    });

    document.getElementById('btnStartLevel').addEventListener('click', startGame);
    document.getElementById('btnBackToMenu').addEventListener('click', () => showScreen('mainMenu'));
    document.getElementById('btnBackToMenuInGame').addEventListener('click', () => showScreen('mainMenu'));
    document.getElementById('btnNextLevel').addEventListener('click', () => {
      if (gameState.currentLevel < MAX_LEVELS) {
        gameState.currentLevel++;
        updateLevelButtons();
        startGame();
      }
    });
    document.getElementById('btnReplay').addEventListener('click', startGame);
    document.getElementById('btnToMenuVictory').addEventListener('click', () => showScreen('mainMenu'));
    document.getElementById('btnRetry').addEventListener('click', startGame);
    document.getElementById('btnToMenuGameOver').addEventListener('click', () => showScreen('mainMenu'));

    // Старт
    updateLevelButtons();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
