<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0" />
  <title>Шарики-рикошет</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #d6e2eb;
      font-family: sans-serif;
      user-select: none;
    }
    #gameCanvas {
      display: block;
      background: #d6e2eb;
      width: 100%;
      height: 100%;
    }
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .screen {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      padding: 20px;
      pointer-events: auto;
    }
    .screen.active {
      display: flex;
    }
    button {
      padding: 14px 28px;
      font-size: 18px;
      background: #4a90e2;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      pointer-events: auto;
      margin: 10px;
      width: 80%;
      max-width: 300px;
    }
    .menu-btn {
      position: absolute;
      top: 15px;
      left: 15px;
      padding: 8px 16px;
      font-size: 16px;
      background: rgba(0,0,0,0.5);
      color: white;
      border: none;
      border-radius: 8px;
      pointer-events: auto;
      z-index: 10;
    }
    .timer {
      position: absolute;
      top: 15px;
      right: 15px;
      font-size: 18px;
      background: rgba(255,255,255,0.8);
      padding: 6px 12px;
      border-radius: 8px;
      pointer-events: auto;
      z-index: 10;
    }
    .queue-container {
      position: absolute;
      bottom: 30px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      pointer-events: auto;
    }
    .ball-queue {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid white;
    }
    .ball-in-cannon {
      position: absolute;
      bottom: 30px;
      left: 55px;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid white;
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="ui">
    <div id="mainMenu" class="screen active">
      <h2 style="font-size: 24px; margin-bottom: 20px; color: #333;">Шарики-рикошет</h2>
      <button id="btnDifficulty">Сложность: Средне</button>
      <button id="btnPlay">Играть</button>
      <button id="btnExit">Выход</button>
    </div>

    <div id="levelSelect" class="screen">
      <h2 style="font-size: 24px; margin-bottom: 20px;">Уровень</h2>
      <div style="display: flex; gap: 10px; margin: 10px 0;">
        <button id="btnPrev">←</button>
        <button id="btnCurrent">1</button>
        <button id="btnNext">→</button>
      </div>
      <button id="btnStartLevel">Начать</button>
      <button id="btnBackToMenu">Назад</button>
    </div>

    <div id="inGameUI" class="screen">
      <div class="timer" id="timer">00:00</div>
      <button class="menu-btn" id="btnBackToMenuInGame">Назад</button>
      <div class="queue-container" id="queueDisplay"></div>
      <div class="ball-in-cannon" id="cannonBall"></div>
    </div>

    <div id="victoryScreen" class="screen">
      <h2 style="font-size: 24px;">Победа!</h2>
      <div id="starsDisplay" style="font-size: 32px; margin: 15px 0;">⭐⭐⭐</div>
      <div id="timeDisplay" style="font-size: 18px;">Время: 00:00</div>
      <button id="btnNextLevel">Следующий уровень</button>
      <button id="btnReplay">Повторить</button>
      <button id="btnToMenuVictory">В меню</button>
    </div>

    <div id="gameOverScreen" class="screen">
      <h2 style="font-size: 24px;">Поражение!</h2>
      <button id="btnRetry">Повторить</button>
      <button id="btnToMenuGameOver">В меню</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let config = {
      BALL_RADIUS: 0,
      CANNON_X: 0,
      CANNON_Y: 0,
      DEATH_LINE_Y: 0,
      MIN_AIM_DISTANCE: 0
    };

    function updateConfig() {
      config.BALL_RADIUS = canvas.height * 0.01875;
      config.CANNON_X = canvas.width / 2;
      config.CANNON_Y = canvas.height - canvas.height * 0.0625;
      config.DEATH_LINE_Y = config.CANNON_Y - canvas.height * 0.125;
      config.MIN_AIM_DISTANCE = canvas.height * 0.05;
    }

    function resizeCanvas() {
      const displayWidth = window.innerWidth;
      const displayHeight = window.innerHeight;
      const aspectRatio = 9 / 15;
      let width, height;
      if (displayWidth / displayHeight > aspectRatio) {
        height = displayHeight;
        width = height * aspectRatio;
      } else {
        width = displayWidth;
        height = width / aspectRatio;
      }
      canvas.width = width;
      canvas.height = height;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      canvas.style.margin = 'auto';
      canvas.style.position = 'absolute';
      canvas.style.top = '50%';
      canvas.style.left = '50%';
      canvas.style.transform = 'translate(-50%, -50%)';
      updateConfig();
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'];
    const MAX_LEVELS = 100;
    const TIME_LIMIT = 12 * 60 * 1000;

    function randomColor() {
      return COLORS[Math.floor(Math.random() * COLORS.length)];
    }

    function formatTime(ms) {
      const totalSec = Math.floor(ms / 1000);
      const min = Math.floor(totalSec / 60).toString().padStart(2, '0');
      const sec = (totalSec % 60).toString().padStart(2, '0');
      return `${min}:${sec}`;
    }

    function getStars(timeMs) {
      if (timeMs <= 4 * 60 * 1000) return 3;
      if (timeMs <= 8 * 60 * 1000) return 2;
      if (timeMs <= 12 * 60 * 1000) return 1;
      return 0;
    }

    class Ball {
      constructor(x, y, color, isFalling = false) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.isFalling = isFalling;
        this.radius = config.BALL_RADIUS;
        this.vy = 0;
      }
      draw(ctx, alpha = 1) {
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
        ctx.restore();
      }
    }

    class LevelBuffer {
      constructor() { this.levels = []; }
      get(id) { return this.levels.find(l => l.id === id); }
      save(id, structure, stars = null) {
        if (this.get(id)) return;
        this.levels.push({ id, structure: [...structure], stars });
        if (this.levels.length > 3) this.levels.shift();
      }
      setStars(id, stars) {
        const level = this.get(id);
        if (level) level.stars = stars;
      }
    }

    class Queue {
      constructor(difficulty) {
        this.difficulty = difficulty;
        this.colors = [];
        this.refill();
      }
      refill() {
        while (this.colors.length < this.difficulty) {
          this.colors.push(randomColor());
        }
      }
      currentColor() { return this.colors[0] || randomColor(); }
      pop() {
        const color = this.colors.shift();
        this.colors.push(randomColor());
        return color;
      }
      nextColors() { return this.colors.slice(1); }
    }

    class Structure {
      constructor() { this.balls = []; }
      add(ball) { this.balls.push(ball); }
      removeGroup(group) {
        const removed = [];
        for (let ball of group) {
          const idx = this.balls.indexOf(ball);
          if (idx !== -1) {
            removed.push({ x: ball.x, y: ball.y, color: ball.color });
            this.balls.splice(idx, 1);
          }
        }
        return removed;
      }
      findConnected(startBall) {
        const visited = new Set();
        const stack = [startBall];
        const group = [];
        const targetColor = startBall.color;
        while (stack.length > 0) {
          const current = stack.pop();
          if (visited.has(current)) continue;
          visited.add(current);
          if (current.color === targetColor) {
            group.push(current);
            for (let other of this.balls) {
              if (visited.has(other)) continue;
              const dx = other.x - current.x;
              const dy = other.y - current.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist <= config.BALL_RADIUS * 2 + 2) {
                stack.push(other);
              }
            }
          }
        }
        return group.length >= 3 ? group : [];
      }

      updateConnectedness() {
        if (this.balls.length === 0) return;

        const connected = new Set();
        const queue = [];
        const CEILING_Y = canvas.height * 0.125;

        for (const ball of this.balls) {
          if (ball.y <= CEILING_Y + config.BALL_RADIUS) {
            connected.add(ball);
            queue.push(ball);
          }
        }

        while (queue.length > 0) {
          const current = queue.shift();
          for (const other of this.balls) {
            if (connected.has(other)) continue;
            const dx = other.x - current.x;
            const dy = other.y - current.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= config.BALL_RADIUS * 2 + 2) {
              connected.add(other);
              queue.push(other);
            }
          }
        }

        for (const ball of this.balls) {
          ball.isFalling = !connected.has(ball);
        }
      }

      checkGameOver(deathLineY) {
        for (let b of this.balls) {
          if (!b.isFalling && b.y + b.radius >= deathLineY) return true;
        }
        return false;
      }

      collectFalling() {
        const falling = this.balls.filter(b => b.isFalling);
        this.balls = this.balls.filter(b => !b.isFalling);
        return falling;
      }
    }

    const levelBuffer = new LevelBuffer();
    let gameState = {
      mode: 'menu',
      difficulty: 2,
      currentLevel: 1,
      queue: null,
      structure: null,
      startTime: null,
      elapsedTime: 0,
      cannonAngle: 0,
      isAiming: false,
      aimPoint: { x: 0, y: 0 },
      fallingBalls: [],
      flyingBalls: [],
      disappearingBalls: [],
      lastFrame: 0,
      isShooting: false
    };

    function generateLevelStructure(levelId) {
      const structure = new Structure();
      const rows = 3 + Math.min(2, Math.floor(levelId / 20));
      const cols = 8;
      const startX = canvas.width / 2 - (cols * config.BALL_RADIUS * 2) / 2 + config.BALL_RADIUS;
      const startY = canvas.height * 0.125;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          if (Math.random() < 0.2) continue;
          const x = startX + col * config.BALL_RADIUS * 2;
          const y = startY + row * config.BALL_RADIUS * 2;
          structure.add(new Ball(x, y, randomColor()));
        }
      }
      return structure;
    }

    function drawBackground() {
      ctx.fillStyle = '#d6e2eb';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawCannon() {
      ctx.save();
      ctx.translate(config.CANNON_X, config.CANNON_Y);
      ctx.rotate(gameState.cannonAngle);
      ctx.beginPath();
      ctx.moveTo(-12, 0);
      ctx.lineTo(12, 0);
      ctx.lineTo(6, -35);
      ctx.lineTo(-6, -35);
      ctx.closePath();
      ctx.fillStyle = '#555';
      ctx.fill();
      ctx.restore();
    }

    function drawAimLine() {
      if (!gameState.isAiming) return;
      const points = [];
      let x = config.CANNON_X;
      let y = config.CANNON_Y;
      const dx = gameState.aimPoint.x - config.CANNON_X;
      const dy = gameState.aimPoint.y - config.CANNON_Y;
      const angle = Math.atan2(dx, -dy);
      let vx = Math.sin(angle) * 10;
      let vy = -Math.cos(angle) * 10;
      let length = 0;
      const maxLength = canvas.height * 0.6;
      while (length < maxLength) {
        x += vx;
        y += vy;
        length += Math.sqrt(vx * vx + vy * vy);
        if (x <= config.BALL_RADIUS) {
          x = config.BALL_RADIUS;
          vx = -vx;
        } else if (x >= canvas.width - config.BALL_RADIUS) {
          x = canvas.width - config.BALL_RADIUS;
          vx = -vx;
        }
        points.push({ x, y });
        if (y <= canvas.height * 0.1) break;
      }
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.setLineDash([6, 4]);
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawDeathLine() {
      ctx.strokeStyle = '#ff000044';
      ctx.setLineDash([10, 5]);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, config.DEATH_LINE_Y);
      ctx.lineTo(canvas.width, config.DEATH_LINE_Y);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function render() {
      drawBackground();
      if (gameState.mode === 'playing') {
        drawDeathLine();
        drawAimLine();
        for (const ball of gameState.structure.balls) {
          if (ball && typeof ball.draw === 'function') ball.draw(ctx);
        }
        for (const ball of gameState.fallingBalls) {
          if (ball && typeof ball.draw === 'function') ball.draw(ctx);
        }
        for (const fb of gameState.flyingBalls) {
          if (fb) {
            const tempBall = new Ball(fb.x, fb.y, fb.color);
            tempBall.draw(ctx);
          }
        }
        for (const db of gameState.disappearingBalls) {
          if (db && db.ball) {
            const alpha = Math.max(0, 1 - (db.time || 0) / 500);
            db.ball.draw(ctx, alpha);
          }
        }
        drawCannon();
        ctx.beginPath();
        ctx.arc(
          config.CANNON_X + Math.sin(gameState.cannonAngle) * 40,
          config.CANNON_Y - Math.cos(gameState.cannonAngle) * 40,
          config.BALL_RADIUS,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = (gameState.queue && typeof gameState.queue.currentColor === 'function')
          ? gameState.queue.currentColor()
          : '#999';
        ctx.fill();
      }
    }

    function shoot() {
      if (gameState.mode !== 'playing' || !gameState.isAiming || gameState.isShooting || !gameState.queue) return;

      const dx = gameState.aimPoint.x - config.CANNON_X;
      const dy = gameState.aimPoint.y - config.CANNON_Y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < config.MIN_AIM_DISTANCE) return;

      gameState.isShooting = true;
      const color = gameState.queue.pop();
      const angle = Math.atan2(dx, -dy);
      const speed = canvas.height * 0.01;

      const flyingBall = {
        x: config.CANNON_X,
        y: config.CANNON_Y,
        vx: Math.sin(angle) * speed,
        vy: -Math.cos(angle) * speed,
        color: color
      };

      gameState.flyingBalls.push(flyingBall);

      const animateFlight = (timestamp) => {
        if (gameState.mode !== 'playing') {
          gameState.flyingBalls = gameState.flyingBalls.filter(fb => fb !== flyingBall);
          gameState.isShooting = false;
          return;
        }

        flyingBall.x += flyingBall.vx;
        flyingBall.y += flyingBall.vy;

        if (flyingBall.x <= config.BALL_RADIUS || flyingBall.x >= canvas.width - config.BALL_RADIUS) {
          flyingBall.vx = -flyingBall.vx;
          flyingBall.x = Math.max(config.BALL_RADIUS, Math.min(canvas.width - config.BALL_RADIUS, flyingBall.x));
        }

        let collided = false;
        for (let i = gameState.structure.balls.length - 1; i >= 0; i--) {
          const ball = gameState.structure.balls[i];
          if (!ball) continue;
          const dx = flyingBall.x - ball.x;
          const dy = flyingBall.y - ball.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= config.BALL_RADIUS * 2) {
            const nx = dx / dist;
            const ny = dy / dist;
            const attachX = ball.x + nx * config.BALL_RADIUS * 2;
            const attachY = ball.y + ny * config.BALL_RADIUS * 2;
            const newBall = new Ball(attachX, attachY, flyingBall.color);
            gameState.structure.add(newBall);

            const group = gameState.structure.findConnected(newBall);
            if (group.length >= 3) {
              const removed = gameState.structure.removeGroup(group);
              gameState.disappearingBalls.push(...removed.map(pos => ({
                ball: new Ball(pos.x, pos.y, pos.color),
                time: 0
              })));
            }

            gameState.structure.updateConnectedness();
            const falling = gameState.structure.collectFalling();
            gameState.fallingBalls.push(...falling.map(b => {
              const fallBall = new Ball(b.x, b.y, b.color, true);
              fallBall.vy = 0;
              return fallBall;
            }));

            collided = true;
            break;
          }
        }

        if (!collided && flyingBall.y <= canvas.height * 0.1) {
          const newBall = new Ball(flyingBall.x, canvas.height * 0.1, flyingBall.color);
          gameState.structure.add(newBall);
          gameState.structure.updateConnectedness();
          const falling = gameState.structure.collectFalling();
          gameState.fallingBalls.push(...falling.map(b => {
            const fallBall = new Ball(b.x, b.y, b.color, true);
            fallBall.vy = 0;
            return fallBall;
          }));
          collided = true;
        }

        if (collided) {
          gameState.flyingBalls = gameState.flyingBalls.filter(fb => fb !== flyingBall);
          gameState.isShooting = false;

          if (gameState.structure.checkGameOver(config.DEATH_LINE_Y)) {
            gameState.mode = 'gameOver';
            showScreen('gameOverScreen');
            return;
          }

          if (gameState.structure.balls.length === 0) {
            const time = Date.now() - gameState.startTime;
            const stars = getStars(time);
            levelBuffer.setStars(gameState.currentLevel, stars);
            gameState.mode = 'victory';
            document.getElementById('timeDisplay').textContent = `Время: ${formatTime(time)}`;
            document.getElementById('starsDisplay').textContent = '⭐'.repeat(stars);
            showScreen('victoryScreen');
            return;
          }

          if (gameState.queue) {
            updateQueueDisplay();
          }
          return;
        }

        requestAnimationFrame(animateFlight);
      };

      requestAnimationFrame(animateFlight);
    }

    function updateFallingBalls(deltaTime) {
      const gravity = canvas.height * 0.0002;
      for (let i = gameState.fallingBalls.length - 1; i >= 0; i--) {
        const ball = gameState.fallingBalls[i];
        if (!ball || typeof ball.vy !== 'number') {
          gameState.fallingBalls.splice(i, 1);
          continue;
        }
        ball.vy += gravity * (deltaTime / 16);
        ball.y += ball.vy;
        if (ball.y > canvas.height + 100) {
          gameState.fallingBalls.splice(i, 1);
        }
      }
    }

    function updateDisappearingBalls(deltaTime) {
      for (let i = gameState.disappearingBalls.length - 1; i >= 0; i--) {
        const db = gameState.disappearingBalls[i];
        if (!db) {
          gameState.disappearingBalls.splice(i, 1);
          continue;
        }
        db.time = (db.time || 0) + deltaTime;
        if (db.time >= 500) {
          gameState.disappearingBalls.splice(i, 1);
        }
      }
    }

    function gameLoop(timestamp) {
      const deltaTime = timestamp - gameState.lastFrame;
      gameState.lastFrame = timestamp;

      if (gameState.mode === 'playing') {
        gameState.elapsedTime = Date.now() - gameState.startTime;
        try {
          document.getElementById('timer').textContent = formatTime(gameState.elapsedTime);
        } catch (e) { /* игнор */ }

        if (gameState.elapsedTime > TIME_LIMIT) {
          gameState.mode = 'gameOver';
          showScreen('gameOverScreen');
          return;
        }

        updateFallingBalls(deltaTime);
        updateDisappearingBalls(deltaTime);
      }

      render();
      requestAnimationFrame(gameLoop);
    }

    function showScreen(id) {
      try {
        document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
        document.getElementById(id).classList.add('active');
      } catch (e) { /* игнор */ }
    }

    function returnToMainMenu() {
      gameState.mode = 'menu';
      gameState.structure = null;
      gameState.queue = null;
      gameState.flyingBalls = [];
      gameState.fallingBalls = [];
      gameState.disappearingBalls = [];
      gameState.isAiming = false;
      gameState.isShooting = false;
      showScreen('mainMenu');
    }

    function startGame() {
      const levelData = levelBuffer.get(gameState.currentLevel);
      let structure;
      if (levelData) {
        structure = new Structure();
        structure.balls = levelData.structure.map(b => new Ball(b.x, b.y, b.color));
      } else {
        structure = generateLevelStructure(gameState.currentLevel);
        levelBuffer.save(gameState.currentLevel, structure.balls);
      }

      gameState.mode = 'playing';
      gameState.structure = structure;
      gameState.queue = new Queue(gameState.difficulty);
      gameState.startTime = Date.now();
      gameState.elapsedTime = 0;
      gameState.fallingBalls = [];
      gameState.flyingBalls = [];
      gameState.disappearingBalls = [];
      gameState.cannonAngle = 0;
      gameState.isAiming = false;
      gameState.isShooting = false;
      try {
        document.getElementById('timer').textContent = '00:00';
      } catch (e) { /* игнор */ }
      updateQueueDisplay();
      showScreen('inGameUI');
    }

    function updateQueueDisplay() {
      try {
        const container = document.getElementById('queueDisplay');
        if (!container) return;
        container.innerHTML = '';

        if (!gameState.queue || typeof gameState.queue.nextColors !== 'function') return;

        const next = gameState.queue.nextColors();
        for (let color of next) {
          const div = document.createElement('div');
          div.className = 'ball-queue';
          div.style.backgroundColor = color;
          container.appendChild(div);
        }

        const cannonBall = document.getElementById('cannonBall');
        if (cannonBall && gameState.queue && typeof gameState.queue.currentColor === 'function') {
          cannonBall.style.backgroundColor = gameState.queue.currentColor();
        }
      } catch (e) { /* игнор */ }
    }

    function getCanvasCoords(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }

    function isPointInCanvas(x, y) {
      const rect = canvas.getBoundingClientRect();
      return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
    }

    function isClickOnButton(clientX, clientY) {
      const backButton = document.getElementById('btnBackToMenuInGame');
      if (!backButton) return false;

      const btnRect = backButton.getBoundingClientRect();
      return (
        clientX >= btnRect.left &&
        clientX <= btnRect.right &&
        clientY >= btnRect.top &&
        clientY <= btnRect.bottom
      );
    }

    function handleTouchStart(e) {
      if (gameState.mode !== 'playing') return;
      if (e.touches.length === 0) return;

      const touch = e.touches[0];
      if (!isPointInCanvas(touch.clientX, touch.clientY)) return;

      if (isClickOnButton(touch.clientX, touch.clientY)) {
        e.preventDefault();
        returnToMainMenu();
        return;
      }

      e.preventDefault();
      const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
      gameState.isAiming = true;
      gameState.aimPoint = { x, y };
      gameState.cannonAngle = Math.atan2(x - config.CANNON_X, -(y - config.CANNON_Y));
    }

    function handleTouchMove(e) {
      if (!gameState.isAiming || gameState.mode !== 'playing') return;
      if (e.touches.length === 0) return;

      const touch = e.touches[0];
      if (!isPointInCanvas(touch.clientX, touch.clientY)) return;

      if (isClickOnButton(touch.clientX, touch.clientY)) {
        e.preventDefault();
        return;
      }

      e.preventDefault();
      const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
      gameState.aimPoint = { x, y };
      gameState.cannonAngle = Math.atan2(x - config.CANNON_X, -(y - config.CANNON_Y));
    }

    function handleTouchEnd(e) {
      if (gameState.mode !== 'playing') return;
      e.preventDefault();

      if (isClickOnButton(e.changedTouches[0].clientX, e.changedTouches[0].clientY)) {
        returnToMainMenu();
        return;
      }

      if (gameState.isAiming) {
        shoot();
      }
      gameState.isAiming = false;
    }

    document.addEventListener('touchstart', handleTouchStart, { passive: false });
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleTouchEnd, { passive: false });
    document.addEventListener('touchcancel', () => { gameState.isAiming = false; }, { passive: false });

    // === Кнопки ===
    document.getElementById('btnExit')?.addEventListener('click', () => {});
    document.getElementById('btnDifficulty')?.addEventListener('click', () => {
      const btn = document.getElementById('btnDifficulty');
      if (!btn) return;
      gameState.difficulty = gameState.difficulty % 3 + 1;
      const labels = { 1: 'Сложно', 2: 'Средне', 3: 'Легко' };
      btn.textContent = `Сложность: ${labels[gameState.difficulty]}`;
    });
    document.getElementById('btnPlay')?.addEventListener('click', () => showScreen('levelSelect'));

    const levelBtn = document.getElementById('btnCurrent');
    const prevBtn = document.getElementById('btnPrev');
    const nextBtn = document.getElementById('btnNext');

    function updateLevelButtons() {
      if (levelBtn) levelBtn.textContent = gameState.currentLevel;
      if (prevBtn) prevBtn.disabled = gameState.currentLevel === 1;
      if (nextBtn) nextBtn.disabled = gameState.currentLevel === MAX_LEVELS;
    }

    prevBtn?.addEventListener('click', () => {
      if (gameState.currentLevel > 1) {
        gameState.currentLevel--;
        updateLevelButtons();
      }
    });

    nextBtn?.addEventListener('click', () => {
      if (gameState.currentLevel < MAX_LEVELS) {
        gameState.currentLevel++;
        updateLevelButtons();
      }
    });

    document.getElementById('btnStartLevel')?.addEventListener('click', startGame);
    document.getElementById('btnBackToMenu')?.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      returnToMainMenu();
    });
    document.getElementById('btnBackToMenuInGame')?.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      returnToMainMenu();
    });
    document.getElementById('btnNextLevel')?.addEventListener('click', () => {
      if (gameState.currentLevel < MAX_LEVELS) {
        gameState.currentLevel++;
        updateLevelButtons();
        startGame();
      }
    });
    document.getElementById('btnReplay')?.addEventListener('click', startGame);
    document.getElementById('btnToMenuVictory')?.addEventListener('click', () => showScreen('mainMenu'));
    document.getElementById('btnRetry')?.addEventListener('click', startGame);
    document.getElementById('btnToMenuGameOver')?.addEventListener('click', () => showScreen('mainMenu'));

    updateLevelButtons();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
